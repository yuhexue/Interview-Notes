## C++基础

### C++和C的区别 

面向对象和面向过程，C++可视为C的扩展，包含继承，多态等特性。

### 请说一下static

1，对于函数定义和代码块之外的变量声明，static 修改标识符的**链接属性**，由默认的 external 变为 internal，作用域和存储类型不改变，这些符号只能在声明它们的源文件中访问。

2，对于代码块内部的变量声明，static 修改标识符的**存储类型**，由自动变量改为静态变量，作用域和链接属性不变。这种变量在程序执行之前就创建，在程序执行的整个周期都存在。

3，对于被 static 修饰的普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用，在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。

4，对于被 static 修饰的类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过<类名>::<静态成员>来使用。但是在 static 函数内不能访问非静态成员。

### const的作用

1，const修饰基本数据类型

 (1),const修饰一般常量及数组

 基本数据类型，修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。 

 (2),const修饰指针变量*及引用变量&  

如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；

如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。

2，const修饰函数

修饰参数和返回值，作用同上。

3，const在类中的用法

不能修改所在类的的任何变量，如：

```c++
A fun4()const;
```

4，const修饰类对象，定义常量对象 
常量对象只能调用常量函数，别的成员函数都不能调用。

实例举例：

### volatile作用

volatile定义变量的值是易变的，每次访问时都从内存中取值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值），而不是读寄存器内的备份。

特性：

Volatile第一个特性：易变性。在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。

Volatile关键词的第二个特性：“不可优化”特性。volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。

Volatile关键词的第三个特性：”顺序性”，能够保证Volatile变量间的顺序性，编译器不会进行乱序优化。



应用深层：

1，C/C++ Volatile变量，与非Volatile变量之间的操作，是可能被编译器交换顺序的。C/C++ Volatile变量间的操作，是不会被编译器交换顺序的。哪怕将所有的变量全部都声明为volatile，哪怕杜绝了编译器的乱序优化，但是针对生成的汇编代码，CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力
针对这个多线程的应用，真正正确的做法，是构建一个happens-before语义。

2，多线程中被几个任务共享的变量需要定义为volatile类型。

3，volatile 关键字声明的变量，

[C/C++ Volatile关键词深度剖析](http://hedengcheng.com/?p=725)

### 宏定义和typedef、内联函数区别

宏是预编译器的输入，然后宏展开之后的结果会送去编译器做语法分析。宏替换发生在编译阶段之前，属于文本插入替换，不检查类型（函数参数，返回值什么的）



typedef是编译的一部分，typedef会检查数据类型。



内联函数是代码被插入到调用者代码处的函数。内联函数本身是函数，进行参数类型检查（编译时），强调函数特性。内联函数省去了函数调用时的压栈出栈。

内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样。

内联函数必须是和函数体声明在一起，才有效。

### c++怎么定义常量，常量放在什么位置

常量定义必须初始化。对于局部对象，常量存放在栈区，对于全局对象，常量存放在全局/静态存储区。对于字面值常量，常量存放在常量存储区。

### 四种cast转换 

C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast
1、const_cast
用于将const 变量转为非const
2、static_cast
用于各种隐式转换，比如非const 转const，void*转指针等, static_cast 能用于多态向上转化，如果向下转能成功但是不安全，结果未知；
3、dynamic_cast
用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。
向上转换：指的是子类向基类的转换
向下转换：指的是基类向子类的转换
它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。
4、reinterpret_cast
几乎什么都可以转，比如将int 转指针，可能会出问题，尽量少用；

### 隐式类型转换

首先，对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换，其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。

### 指针和引用的区别？ 

区别：

1，指针是变量，内容是所指内存的地址，而引用只是内存的别名，不分配内存空间；
2，指针可变；引用只能在定义时被初始化一次，之后不可变；
3，引用不能为空，指针可以为空；
4，指针可以有多级指针（**p），而引用至于一级；
5，指针和引用使用++运算符的意义不一样；
6，如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。

### 介绍智能指针及其实现（实现见牛客30题）

C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr ，第一个已被C++11 弃用。

智能指针的作用：

管理指针，指针可能存在忘记释放造成内存泄漏。因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

1，auto_ptr（c++98 的方案，cpp11 已经抛弃）
采用所有权模式。
auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
auto_ptr<string> p2;
p2 = p1; //auto_ptr 不会报错.
此时不会报错，p2 剥夺了p1 的所有权，但是当程序运行时访问p1 将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！

2，unique_ptr（替换auto_ptr）
unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new 创建对象后因为发生异常而忘记调用delete”)特别有用。
采用所有权模式，还是上面那个例子
unique_ptr<string> p3 (new string ("auto")); //#4
unique_ptr<string> p4； //#5
p4 = p3;//此时会报错！！

编译器认为p4=p3 非法，避免了p3 不再指向有效数据的问题。因此，unique_ptr 比auto_ptr更安全。另外unique_ptr 还有更聪明的地方：当程序试图将一个unique_ptr 赋值给另一个时，如果源unique_ptr 是个临时右值，编译器允许这么做；如果源unique_ptr 将存在一段时间，编译器将禁止这么做，比如：
  unique_ptr<string> pu1(new string ("hello world"));
  unique_ptr<string> pu2;
  pu2 = pu1; // #1 not allowed
  unique_ptr<string> pu3;
  pu3 = unique_ptr<string>(new string ("You")); // #2 allowed

其中#1 留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2 不会留下悬挂的unique_ptr， 因为它调用unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。
注：如果确实想执行类似与#1 的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr 赋给另一个。例如：
  unique_ptr<string> ps1, ps2;
  ps1 = demo("hello");
  ps2 = move(ps1);
  ps1 = demo("alexia");
  cout << *ps2 << *ps1 << endl；



3，shared_ptr
shared_ptr 实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new 来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr 来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0 时，资源会被释放。

shared_ptr 是为了解决auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。成员函数：
  use_count 返回引用计数的个数
  unique 返回是否是独占所有权( use_count 为1)
  swap 交换两个shared_ptr 对象(即交换所拥有的对象)
  reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少
  get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如
  shared_ptr<int> sp(new int(1)); sp 与sp.get()是等价的

4，weak_ptr

weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个shared_ptr 管理的对象.进行该对象的内存管理的是那个强引用的shared_ptr. weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合shared_ptr 而引入的一种智能指针来协助shared_ptr 工作, 它只可以从一个shared_ptr 或另一个weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr 是用来解决shared_ptr 相互引用时的死锁问题,如果说两个shared_ptr 相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它可以通过调用lock 函数来获得shared_ptr。
class B;
class A
{
public:
shared_ptr<B> pb_;
~A()
{
cout<<"A delete\n";
}
};

class B
{
public:
shared_ptr<A> pa_;
~B()
{
cout<<"B delete\n";
}
};
void fun()
{

shared_ptr<B> pb(new B());
shared_ptr<A> pa(new A());
pb->pa_ = pa;
pa->pb_ = pb;
cout<<pb.use_count()<<endl;
cout<<pa.use_count()<<endl;
}
int main()
{
fun();
return 0;
}

可以看到fun 函数中pa ，pb 之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb 析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B 的析构函数没有被调用），如果把其中一个改为weak_ptr 就可以了，我们把类A 里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B 的引用开始就只有1，当pb 析构时，B 的计数变为0，B 得到释放，B 释放的同时也会使A 的计数减一，同时pa 析构时使A 的计数减一，那么A 的计数为0，A 得到释放。注意的是我们不能通过weak_ptr 直接访问对象的方法，比如B 对象中有一个方法print(),我们不能这样访问，pa->pb_->print(); 英文pb_是一个weak_ptr，应该先把它转化为
shared_ptr,如：shared_ptr p = pa->pb_.lock(); p->print();



链接：

https://www.cnblogs.com/DswCnblog/p/5628195.html

https://www.cnblogs.com/diysoul/p/5930361.html

https://www.cnblogs.com/diysoul/p/5930372.html

一个基于计数的智能指针的实现：

```c++
template <typename T>
class SmartPointer {
public:
	//构造函数
	SmartPointer(T* p=0): _ptr(p), _reference_count(new size_t){
		if(p)
			*_reference_count = 1; 
		else
			*_reference_count = 0; 
	}
	//拷贝构造函数
	SmartPointer(const SmartPointer& src) {
		if(this!=&src) {
			_ptr = src._ptr;
			_reference_count = src._reference_count;
			(*_reference_count)++;
		}
	}
	//重载赋值操作符
	SmartPointer& operator=(const SmartPointer& src) {
		if(_ptr==src._ptr) {
			return *this;
		}
		releaseCount();
		_ptr = src._ptr;
		_reference_count = src._reference_count;
		(*_reference_count)++;
		return *this;
	}
 
	//重载操作符
	T& operator*() {
		if(ptr) {
			return *_ptr;
		}
		//throw exception
	}
	//重载操作符
	T* operator->() {
		if(ptr) {
			return _ptr;
		}
		//throw exception
	}
	//析构函数
	~SmartPointer() {
		if (--(*_reference_count) == 0) {
            delete _ptr;
            delete _reference_count;
        }
	}
private:
	T *_ptr;
        size_t *_reference_count;
        void releaseCount() {
		if(_ptr) {
			(*_reference_count)--;
    			if((*_reference_count)==0) {
    				delete _ptr;
    				delete _reference_count;
    			}
		}
    	}
};
 
int main() 
{
    SmartPointer<char> cp1(new char('a'));
    SmartPointer<char> cp2(cp1);
    SmartPointer<char> cp3;
    cp3 = cp2;
    cp3 = cp1;
    cp3 = cp3;
    SmartPointer<char> cp4(new char('b'));
    cp3 = cp4;
}
```



### 数组和指针的区别

指针                             数组
保存数据的地址            保存数据
间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据         直接访问数据，
通常用于动态的数据结构                                  通常用于固定数目且数据类型相同的元素

通过Malloc 分配内存，free 释放内存          隐式的分配和删除
通常指向匿名数据，操作匿名函数           自身即为数据名

### 空指针和野指针 

野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针

描述一下危害和怎么解决



### 防止指针的越界使用，

必须让指针指向一个有效的内存地址, 
1 防止数组越界 
2 防止向一块内存中拷贝过多的内容 
3 防止使用空指针 
4 防止改变const修改的指针 
5 防止改变指向静态存储区的内容 
6 防止两次释放一个指针 
7 防止使用野指针. 

### 堆和栈上的指针

指针所指向的这块内存是在哪里分配的,在堆上称为堆上的指针,在栈上为栈上的指针. 
在堆上的指针,可以保存在全局数据结构中,供不同函数使用访问同一块内存. 
在栈上的指针,在函数退出后,该内存即不可访问.  

### 智能指针有没有内存泄露的情况 ，如何解决 

当两个对象相互使用一个shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失
效，从而导致内存泄漏。例如：

![1](C:\Users\yuhexue\Desktop\1.png)

![2](C:\Users\yuhexue\Desktop\2.png)

![3](C:\Users\yuhexue\Desktop\3.png)

上述代码中，parent 有一个shared_ptr 类型的成员指向孩子，而child 也有一个shared_ptr
类型的成员指向父亲。然后在创建孩子和父亲对象时也使用了智能指针c 和p，随后将c 和p 分
别又赋值给child 的智能指针成员parent 和parent 的智能指针成员child。从而形成了一个循
环引用：



如何解决智能指针的内存泄漏

为了解决循环引用导致的内存泄漏，引入了weak_ptr 弱指针，weak_ptr 的构造函数不会修
改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的
共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。 

### 为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 

将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new 一个子类，然后使用
基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。
C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的
内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的
析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

### 函数指针和用途

1、定义
函数指针是指向函数的指针变量。
函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可
指向整型变量、字符型、数组一样，这里是指向函数。
C 在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了
指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，
在这些概念上是大体一致的。
2、用途：
调用函数和做函数的参数，比如回调函数。
3、示例：
char * fun(char * p) {…} // 函数fun
char * (*pf)(char * p); // 函数指针pf
pf = fun; // 函数指针pf 指向函数fun
pf(p); // 通过函数指针pf 调用函数fun

### 构造函数和析构函数

析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统
会自动执行析构函数。
析构函数名也应与类名相同，只是在函数名前面加一个位取反符~，例如~stud( )，以区别
于构造函数。它不能带任何参数，也没有返回值（包括void 类型）。只能有一个析构函数，不
能重载。
如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构
函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时
会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类
中没有用显式的析构函数。
如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在
销毁类之前，释放掉申请的内存空间，避免内存泄漏。
类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。

### 多态 

静态和动态，重载和重写，虚函数

多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动
态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个
子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写
过后的函数，在父类中声明为加了virtual 关键字的函数，在子类中重写时候不需要加virtual
也是虚函数。
虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个
虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时
候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换
为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。

### 虚函数及其实现原理

\###虚函数： 虚函数的作用和实现原理，什么是虚函数,有什么作用?

```
C++的多态分为静态多态（编译时多态）和动态多态（运行时多态）两大类。静态多态通过重载、模板来实现；动态多态就是通过本文的主角虚函数来体现的。   
         
虚函数实现原理:包括虚函数表、虚函数指针等 
 
虚函数的作用说白了就是：当调用一个虚函数时，被执行的代码必须和调用函数的对象的动态类型相一致。编译器需要做的就是如何高效的实现提供这种特性。不同编译器实现细节也不相同。大多数编译器通过vtbl（virtual table）和vptr（virtual table pointer）来实现的。 当一个类声明了虚函数或者继承了虚函数，这个类就会有自己的vtbl。vtbl实际上就是一个函数指针数组，有的编译器用的是链表，不过方法都是差不多。vtbl数组中的每一个元素对应一个函数指针指向该类的一个虚函数，同时该类的每一个对象都会包含一个vptr，vptr指向该vtbl的地址。
```

结论：

```
每个声明了虚函数或者继承了虚函数的类，都会有一个自己的vtbl
同时该类的每个对象都会包含一个vptr去指向该vtbl
虚函数按照其声明顺序放于vtbl表中, vtbl数组中的每一个元素对应一个函数指针指向该类的虚函数
如果子类覆盖了父类的虚函数，将被放到了虚表中原来父类虚函数的位置
在多继承的情况下，每个父类都有自己的虚表。子类的成员函数被放到了第一个父类的表中
```

衍生问题:为什么 C++里访问虚函数比访问普通函数慢?

```
单继承时性能差不多，多继承的时候会慢
```

调用性能方面

```
从前面虚函数的调用过程可知。当调用虚函数时过程如下（引自More Effective C++）:
 
通过对象的 vptr 找到类的 vtbl。这是一个简单的操作,因为编译器知道在对象内 哪里能找到 vptr(毕竟是由编译器放置的它们)。因此这个代价只是一个偏移调整(以得到 vptr)和一个指针的间接寻址(以得到 vtbl)。
找到对应 vtbl 内的指向被调用函数的指针。这也是很简单的, 因为编译器为每个虚函数在 vtbl 内分配了一个唯一的索引。这步的代价只是在 vtbl 数组内 的一个偏移。
调用第二步找到的的指针所指向的函数。
在单继承的情况下，调用虚函数所需的代价基本上和非虚函数效率一样，在大多数计算机上它多执行了很少的一些指令，所以有很多人一概而论说虚函数性能不行是不太科学的。在多继承的情况下，由于会根据多个父类生成多个vptr，在对象里为寻找 vptr 而进行的偏移量计算会变得复杂一些，但这些并不是虚函数的性能瓶颈。 虚函数运行时所需的代价主要是虚函数不能是内联函。这也是非常好理解的，是因为内联函数是指在编译期间用被调用的函数体本身来代替函数调用的指令，但是虚函数的“虚”是指“直到运行时才能知道要调用的是哪一个函数。”但虚函数的运行时多态特性就是要在运行时才知道具体调用哪个虚函数，所以没法在编译时进行内联函数展开。当然如果通过对象直接调用虚函数它是可以被内联，但是大多数虚函数是通过对象的指针或引用被调用的，这种调用不能被内联。 因为这种调用是标准的调用方式，所以虚函数实际上不能被内联。
```

占用空间方面

```
在上面的虚函数实现原理部分，可以看到为了实现运行时多态机制，编译器会给每一个包含虚函数或继承了虚函数的类自动建立一个虚函数表，所以虚函数的一个代价就是会增加类的体积。在虚函数接口较少的类中这个代价并不明显，虚函数表vtbl的体积相当于几个函数指针的体积，如果你有大量的类或者在每个类中有大量的虚函数,你会发现 vtbl 会占用大量的地址空间。但这并不是最主要的代价，主要的代价是发生在类的继承过程中，在上面的分析中，可以看到，当子类继承父类的虚函数时，子类会有自己的vtbl，如果子类只覆盖父类的一两个虚函数接口，子类vtbl的其余部分内容会与父类重复。这在如果存在大量的子类继承，且重写父类的虚函数接口只占总数的一小部分的情况下，会造成大量地址空间浪费。在一些GUI库上这种大量子类继承自同一父类且只覆盖其中一两个虚函数的情况是经常有的，这样就导致UI库的占用内存明显变大。 由于虚函数指针vptr的存在，虚函数也会增加该类的每个对象的体积。在单继承或没有继承的情况下，类的每个对象会多一个vptr指针的体积，也就是4个字节；在多继承的情况下，类的每个对象会多N个（N＝包含虚函数的父类个数）vptr的体积，也就是4N个字节。当一个类的对象体积较大时，这个代价不是很明显，但当一个类的对象很轻量的时候，如成员变量只有4个字节，那么再加上4（或4N）个字节的vptr，对象的体积相当于翻了1（或N）倍，这个代价是非常大的。
```

[C++虚函数浅析](http://glgjing.github.io/blog/2015/01/03/c-plus-plus-xu-han-shu-qian-xi/)

纯虚函数，为什么需要纯虚函数？

```
纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”
 
virtual void funtion1()=0
 
原因：
1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。
2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。
 
为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。
 
定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。
纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。
 
[虚函数和纯虚函数的区别](http://blog.csdn.net/hackbuteer1/article/details/7558868)
```

为什么需要虚析构函数,什么时候不需要?父类的析构函数为什么要定义为虚函数

```
 直接的讲，C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。
当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。所以，只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。
```

内联函数、构造函数、静态成员函数可以是虚函数吗?

```
inline, static, constructor三种函数都不能带有virtual关键字。
inline是编译时展开，必须有实体；
static属于class自己的，也必须有实体；
virtual函数基于vtable（内存空间），constructor函数如果是virtual的，调用时也需要根据vtable寻找，但是constructor是virtual的情况下是找不到的，因为constructor自己本身都不存在了，创建不到class的实例，没有实例，class的成员（除了public static/protected static for friend class/functions，其余无论是否virtual）都不能被访问了。
 
虚函数实际上不能被内联:虚函数运行时所需的代价主要是虚函数不能是内联函。这也是非常好理解的，是因为内联函数是指在编译期间用被调用的函数体本身来代替函数调用的指令，但是虚函数的“虚”是指“直到运行时才能知道要调用的是哪一个函数。”但虚函数的运行时多态特性就是要在运行时才知道具体调用哪个虚函数，所以没法在编译时进行内联函数展开。当然如果通过对象直接调用虚函数它是可以被内联，但是大多数虚函数是通过对象的指针或引用被调用的，这种调用不能被内联。 因为这种调用是标准的调用方式，所以虚函数实际上不能被内联。
 
构造函数不能是虚函数。而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好, 多态是被disable的。 
 
静态的对象是属于整个类的，不对某一个对象而言，同时其函数的指针存放也不同于一般的成员函数，其无法成为一个对象的虚函数的指针以实现由此带来的动态机制。                      
```

构造函数中可以调用虚函数吗?

最后，总结一下关于虚函数的一些常见问题：

```
1) 虚函数是动态绑定的，也就是说，使用虚函数的指针和引用能够正确找到实际类的对应函数，而不是执行定义类的函数。这是虚函数的基本功能，就不再解释了。 
 
2) 构造函数不能是虚函数。而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好, 多态是被disable的。 
 
3) 析构函数可以是虚函数，而且，在一个复杂类结构中，这往往是必须的。
 
4) 将一个函数定义为纯虚函数，实际上是将这个类定义为抽象类，不能实例化对象。 
 
5) 纯虚函数通常没有定义体，但也完全可以拥有。
 
6)  析构函数可以是纯虚的，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。 
 
7) 非纯的虚函数必须有定义体，不然是一个错误。 
 
8) 派生类的override虚函数定义必须和父类完全一致。除了一个特例，如果父类中返回值是一个指针或引用，子类override时可以返回这个指针（或引用）的派生。例如，在上面的例子中，在Base中定义了 virtual Base* clone(); 在Derived中可以定义为 virtual Derived* clone()。可以看到，这种放松对于Clone模式是非常有用的。
```

[虚析构函数(√)、纯虚析构函数(√)、虚构造函数(X)](http://www.cnblogs.com/chio/archive/2007/09/10/888260.html)

为什么需要虚继承?虚继承实现原理解析，

```
虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。
如:类D继承自类B1、B2，而类B1、B2都继 承自类A，因此在类D中两次出现类A中的变量和函数。为了节省内存空间，可以将B1、B2对A的继承定义为虚拟继承，而A就成了虚拟基类,虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间。
 
虚继承的特点是，在任何派生类中的virtual基类总用同一个（共享）对象表示，
```

### 抽象类和纯虚函数

### ++i和i++的区别和实现原理 

1. ++i 实现：
    int& int::operator++（）
    {
    *this +=1；
    return *this；
    }
2. i++ 实现：
    const int int::operator（int）
    {
    int oldValue = *this；
    ++（*this）；
    return oldValue；
    }

### 请你来写个函数在main函数执行前先运行

__attribute((constructor))void before()
{
printf("before main\n");
}

### C++的内存

### C++内存分配

内存分配方式有三种：

（1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。

（2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

（3）从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。





### C++内存管理详解

　　在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。

　　栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

　　堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

　　自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。

　　全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

　　常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

### 隐式类型转换

### new/delete与malloc/free的区别和实现

首先，new/delete 是C++的关键字，而malloc/free 是C 语言的库函数，后者使用必须指明申请
内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数

malloc 需要给定申请内存的大小，返回的指针需要强转。
new 会调用构造函数，不用指定内存大小，返回的指针不用强转。



1、new 分配内存按照数据类型进行分配，malloc 分配内存按照指定的大小分配；
2、new 返回的是指定对象的指针，而malloc 返回的是void*，因此malloc 的返回值一般都
需要进行类型转化。
3、new 不仅分配一段内存，而且会调用构造函数，malloc 不会。
4、new 分配的内存要用delete 销毁，malloc 要用free 来销毁；delete 销毁的时候会调用
对象的析构函数，而free 则不会。
5、new 是一个操作符可以重载，malloc 是一个库函数。
6、malloc 分配的内存不够的时候，可以用realloc 扩容。扩容的原理？new 没用这样操作。
7、new 如果分配失败了会抛出bad_malloc 的异常，而malloc 失败了会返回NULL。
8、申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]
多次调用析构函数，销毁数组中的每个对象。而malloc 则只能sizeof(int) * n。

### select,fork,wait,exec函数

select 在使用前，先将需要监控的描述符对应的bit 位置1，然后将其传给select,当有任何一
个事件发生时，select 将会返回所有的描述符，需要在应用程序自己遍历去检查哪个描述符上
有事件发生，效率很低，并且其不断在内核态和用户态进行描述符的拷贝，开销很大

父进程产生子进程使用fork 拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进
程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec 函数可以加载一个elf
文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork 从父进程返回子进程
的pid，从子进程返回0.调用了wait 的父进程将会发生阻塞，直到有子进程状态改变,执行成功
返回0，错误返回-1。exec 执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1

### C++中struct和class的区别

参考回答：
在C++中，可以用struct 和class 定义类，都可以继承。区别在于：structural 的默认继
承权限和默认访问权限是public，而class 的默认继承权限和默认访问权限是private。
另外，class 还可以定义模板类形参，比如template <class T, int i>。

在使用习惯上，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。

### 什么是右值引用，跟左值有什么区别

参考回答：右值引用是C++11 中引入的新特性, 它实现了转移语义和精确传递。它的主要
目的有两个方面：
1. 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。

2. 能够更简洁明确地定义泛型函数。

  

  左值和右值的概念：
  左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。
  右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。
  右值引用和左值引用的区别：

  1.左值可以寻址，而右值不可以。

  2.左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。

  3. 左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。

### C++设计一个不能被继承的类

构造函数或析构函数为私有函数，所以该类是无法被继承的，



 

## STL基础

### vector的原理

扩容，释放空间

### vector和list的区别，应用

1、概念：
1）Vector
连续存储的容器，动态数组，在堆上分配空间
底层实现：数组
两倍容量增长：
vector 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加
到最后（插入指定位置），然后调整迭代器。
如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复
制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。
性能：

访问： O(1)
插入：在最后插入（空间够）：很快
在最后插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。
在中间插入（空间够）：内存拷贝
在中间插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。
删除：在最后删除：很快
在中间删除：内存拷贝
适用场景：经常随机访问，且不经常对非尾节点进行插入删除。
2、List
动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空
间。
底层：双向链表
性能：

访问：随机访问性能很差，只能快速访问头尾节点。
插入：很快，一般是常数开销
删除：很快，一般是常数开销
适用场景：经常插入删除大量数据
2、区别：
1）vector 底层实现是数组；list 是双向链表。
2）vector 支持随机访问，list 不支持。
3）vector 是顺序内存，list 不是。
4）vector 在中间节点进行插入删除会导致内存拷贝，list 不会。
5）vector 一次性分配好内存，不够时才进行2 倍扩容；list 每次插入新节点都会进行内
存申请。
6）vector 随机访问性能好，插入删除性能差；list 随机访问性能差，插入删除性能好。
3、应用

vector 拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在
乎插入和删除的效率，使用vector。
list 拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应
使用list。

### map和set的区别和实现，unordered_map 和multiply_map等等

map 和set 都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于map 和set 所
开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的map 和set 的操作行为，都只是
转调RB-tree 的操作行为。
map 和set 区别在于：
（1）map 中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索
引相关联的数据；Set 与之相对就是关键字的简单集合，set 中每个元素只包含一个关键字。
（2）set 的迭代器是const 的，不允许修改元素的值；map 允许修改value，但不允许修改
key。其原因是因为map 和set 是根据关键字排序来保证其有序性的，如果允许修改key 的话，
那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏
了map 和set 的结构，导致iterator 失效，不知道应该指向改变前的位置，还是指向改变后的
位置。所以STL 中将set 的迭代器设置成const，不允许修改迭代器的值；而map 的迭代器则不
允许修改key 值，允许修改value 值。
（3）map 支持下标操作，set 不支持下标操作。map 可以用key 做下标，map 的下标运算符[ ]
将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type
类型默认值的元素至map 中，因此下标运算符[ ]在map 应用中需要慎用，const_map 不能用，
只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type 类型没有默
认值也不应该使用。如果find 能解决需要，尽可能用find。





1、Map
映射，map 的所有元素都是pair，同时拥有实值（value）和键值（key）。pair 的第一
元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值
重复。
底层实现：红黑树
适用场景：有序键值对不重复映射
2、Multimap
多重映射。multimap 的所有元素都是pair，同时拥有实值（value）和键值（key）。pair
的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。允许
键值重复。
底层实现：红黑树
适用场景：有序键值对可重复映射

### STL的allocaotr （分配器）

STL 的分配器用于封装STL 容器在内存管理上的底层细节。在C++中，其内存配置和释放如
下：
new 运算分两个阶段：(1)调用::operator new 配置内存;(2)调用对象构造函数构造对象内
容
delete 运算分两个阶段：(1)调用对象希构函数；(2)掉员工::operator delete 释放内存
为了精密分工，STL allocator 将两个阶段操作区分开来：内存配置有alloc::allocate()
负责，内存释放由alloc::deallocate()负责；对象构造由::construct()负责，对象析构
由::destroy()负责。
同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL 采用了两级
配置器，当分配的空间大小超过128B 时，会使用第一级空间配置器；当分配的空间大小小于128B
时，将使用第二级空间配置器。第一级空间配置器直接使用malloc()、realloc()、free()函数
进行内存空间的分配和释放，而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。

### 迭代器的作用，有指针为何还要迭代器，迭代器怎么删除元素的 

这个主要考察的是迭代器失效的问题。1.对于序列容器vector,deque 来说，使用
erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位
置，但是erase 会返回下一个有效的迭代器；2.对于关联容器map set 来说，使用了
erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影
响到下一个元素的迭代器，所以在调用erase 之前，记录下一个元素的迭代器即可。3.对于list
来说，它使用了不连续分配的内存，并且它的erase 方法也会返回下一个有效的iterator，因
此上面两种正确的方法都可以使用。





1、迭代器
Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合
对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator 模
式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况
下，按照一定顺序（由iterator 提供的方法）访问聚合对象中的各个元素。
由于Iterator 模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一
般仅用于底层聚合支持类，如STL 的list、vector、stack 等容器类及ostream_iterator 等扩
展iterator。
2、迭代器和指针的区别
迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了
指针的一些操作符，->、*、++、--等。迭代器封装了指针，是一个“可遍历STL（ Standard Template
Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升
（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构
来实现不同的++，--等操作。
迭代器返回的是对象引用而不是对象的值，所以cout 只能输出迭代器使用*取值后的值而
不能直接输出其自身。
3、迭代器产生原因
Iterator 类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的
结构而达到循环遍历集合的效果。

### fork函数（放到STL里面）

Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);

成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进
程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程
的pid。如果出现错误，fork( )返回一个负值。
最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前
进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执
行文件的映像。这种“派生加执行”的方式是很常见的。
在早期的Unix 系统中，创建进程比较原始。当调用fork 时，内核会把所有的内部数据结构
复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空
间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix 系统采取了更多的优化，
例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。

### 请你回答一下STL里resize和reserve的区别

resize()：改变当前容器内含有元素的数量(size())，eg: vector<int>v; v.resize(len);v
的size 变为len,如果原来v 的size 小于len，那么容器新增（len-size）个元素，元素的值为
默认为0.当v.push_back(3);之后，则是3 是放在了v 的末尾，即下标为len，此时容器是size
为len+1；
reserve()：改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len 个
对象的空间，然后把之前v.size()个对象通过copy construtor 复制过来，销毁之前的内存；
测试代码如下：

```c++
#include <iostream>
#include <vector>
using namespace std;
int main() {
vector<int> a;
a.reserve(100);
a.resize(50);
cout<<a.size()<<" "<<a.capacity()<<endl;
//50 100
a.resize(150);
cout<<a.size()<<" "<<a.capacity()<<endl;
//150 200

a.reserve(50);
cout<<a.size()<<" "<<a.capacity()<<endl;
//150 200
a.resize(50);
cout<<a.size()<<" "<<a.capacity()<<endl;
//50 200
}
```



### 写string类的构造，析构，拷贝函数

String 类的原型如下
class String
{
  public:
         String(const char *str=NULL); //构造函数
         String(const String &other); //拷贝构造函数
         ~String(void); //析构函数
         String& operator=(const String &other); //等号操作符重载
         ShowString();

  private:
         char *m_data; //指针
};

String::~String()
{
   delete [] m_data; //析构函数，释放地址空间
}
String::String(const char *str)
{
   if (str==NULL)//当初始化串不存在的时候，为m_data申请一个空间存放'\0'；
    {
       m_data=new char[1];
       *m_data='\0';
    }
   else//当初始化串存在的时候，为m_data申请同样大小的空间存放该串；
    {
       int length=strlen(str);
       m_data=new char[length+1];
       strcpy(m_data,str);
    }
}

String::String(const String &other)//拷贝构造函数，功能与构造函数类似。
{
   int length=strlen(other.m_data);
   m_data=new [length+1];
   strcpy(m_data,other.m_data);
}
String& String::operator =(const String &other) 
{
   if (this==&other)//当地址相同时，直接返回；
       return *this; 

   delete [] m_data;//当地址不相同时，删除原来申请的空间，重新开始构造；
   int length=sizeof(other.m_data);
   m_data=new [length+1];
   strcpy(m_data,other.m_data);
   return *this; 
}

String::ShowString()//由于m_data是私有成员，对象只能通过public成员函数来访问；
{
     cout<<this->m_data<<endl;
}

int main()
{
    String AD;
    char * p="ABCDE";
    String B(p);
    AD.ShowString();
    AD=B;
    AD.ShowString();
}

```
vector-数组，元素不够时再重新分配内存，拷贝原来数组的元素到新分配的数组中。
list－单链表。
deque-分配中央控制器map(并非map容器)，map记录着一系列的固定长度的数组的地址.记住这个map仅仅保存的是数组的地址,真正的数据在数组中存放着.deque先从map中央的位置(因为双向队列，前后都可以插入元素)找到一个数组地址，向该数组中放入数据，数组不够时继续在map中找空闲的数组来存数据。当map也不够时重新分配内存当作新的map,把原来map中的内容copy的新map中。所以使用deque的复杂度要大于vector，尽量使用vector。
 
stack-基于deque。
queue-基于deque。
heap-完全二叉树，使用最大堆排序，以数组(vector)的形式存放。
priority_queue-基于heap。
slist-双向链表。
 
关联式容器：
set,map,multiset,multimap-基于红黑树(RB-tree)，一种加上了额外平衡条件的二叉搜索树。
 
hash table-散列表。将待存数据的key经过映射函数变成一个数组(一般是vector)的索引，例如：数据的key%数组的大小＝数组的索引(一般文本通过算法也可以转换为数字)，然后将数据当作此索引的数组元素。有些数据的key经过算法的转换可能是同一个数组的索引值(碰撞问题，可以用线性探测，二次探测来解决)，STL是用开链的方法来解决的，每一个数组的元素维护一个list，他把相同索引值的数据存入一个list，这样当list比较短时执行删除，插入，搜索等算法比较快。
 
hash_map,hash_set,hash_multiset,hash_multimap-基于hashtable。
```

[STL六大组件] (<http://blog.csdn.net/chenguolinblog/article/details/30336805>)
 什么是“标准非STL容器”？

list和vector有什么区别？

```
vector拥有一段连续的内存空间，因此支持随机存取，如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector。
list拥有一段不连续的内存空间，因此不支持随机存取，如果需要大量的插入和删除，而不关心随即存取，则应使用list。
```

 



## 编译底层

### C++源文件从文本到可执行文件经历的过程**？** 

对于C++源文件，从文本到可执行文件一般需要四个过程：
预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和
替换，生成预编译文件。
编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件
汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件
链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件

### include**头文件的顺序以及双引号和尖括号**的区别？ 

Include 头文件的顺序：对于include 的头文件来说，如果在文件a.h 中声明一个在文件b.h
中定义的变量，而不引用b.h。那么要在a.c 文件中引用b.h 文件，并且要先引用b.h，后引用
a.h,否则汇报变量类型未声明错误。
双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。
对于使用双引号包含的头文件，查找头文件路径的顺序为：
当前头文件目录
编译器设置的头文件路径（编译器可使用-I 显式指定搜索路径）
系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径
对于使用尖括号包含的头文件，查找头文件的路径顺序为：
编译器设置的头文件路径（编译器可使用-I 显式指定搜索路径）

系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径

### C++的内存管理和内存分配 ，内存泄露（memory leak）的判断

在C++中，虚拟内存分为代码段、数据段、BSS 段、堆区、文件映射区以及栈区六部分。
代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机
器代码。
数据段：存储程序中已初始化的全局变量和静态变量
bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0 的全
局变量和静态变量。
堆区： 调用new/malloc 函数时在堆区动态分配内存，同时需要调用delete/free 来手动释
放申请的内存。
映射区:存储动态链接库以及调用mmap 函数进行的文件映射

栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值







![4](C:\Users\yuhexue\Desktop\4.png)

32bitCPU 可寻址4G 线性空间，每个进程都有各自独立的4G 逻辑地址，其中0~3G 是用户态
空间，3~4G 是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其
划分如下：
各个段说明如下：
3G 用户空间和1G 内核空间
静态区域：
text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本
区存储程序的机器代码。
data segment(数据段)：存储程序中已初始化的全局变量和静态变量
bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0
的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main 之前时会统一清
零。即未初始化的全局变量编译器会初始化为0

动态区域：
heap（堆）： 当进程未调用malloc 时是没有堆段的，只有调用malloc 时采用分配一个堆，
并且在程序运行过程中可以动态增加堆大小(移动break 指针)，从低地址向高地址增长。分配小
内存时使用该区域。堆的起始地址由mm_struct 结构体中的start_brk 标识，结束地址由brk
标识。
memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc 时调
用mmap 函数）
stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低
地址增长。在创建进程时会有一个最大栈大小，Linux 可以通过ulimit 命令指定。



参考回答：
内存泄漏通常是由于调用了malloc/new 等内存申请的操作，但是缺少了对应的free/delete。
为了判断内存是否泄露，我们一方面可以使用linux 环境下的内存泄漏检查工具Valgrind,另一
方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，
以此来判断内存是否泄露。



内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。
内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对
该段内存的控制，因而造成了内存的浪费。
内存泄漏的分类：

1. 堆内存泄漏（Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc
   new 等从堆中分配的一块内存，再是完成后必须通过调用对应的free 或者delete 删掉。如果
   程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap
   Leak.
2. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如
   Bitmap,handle ,SOCKET 等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统
   效能降低，系统运行不稳定。
3. 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函
   数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内
   存泄露。

### **malloc的原理**，**另外**brk系统调用**和m**map**系统调用的作用分别是什么

Malloc 函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc 其采用内存
池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单
位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc 采用隐式链表结构将堆区
分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc 采用显示链表结构来管理
所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分
配的地址。
当进行内存分配时，Malloc 会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分
配；当进行内存合并时，malloc 采用边界标记法，根据每个块的前后块是否已经分配来决定是
否进行块合并。
Malloc 在申请内存时，一般会通过brk 或者mmap 系统调用进行申请。其中当申请内存小于
128K 时，会使用系统函数brk 在堆区中分配；而当申请内存大于128K 时，会使用系统函数mmap
在映射区分配。

### 什么时候会发生段错误 

段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：
使用野指针
试图修改字符串常量的内容

### reactor模型

reactor 模型要求主线程只负责监听文件描述上是否有事件发生，有的话就立即将该事件通
知工作线程，除此之外，主线程不做任何其他实质性的工作，读写数据、接受新的连接以及处理
客户请求均在工作线程中完成。

![5](C:\Users\yuhexue\Desktop\5.png)

1）Handle：即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开
的文件、一个连接(Socket)、Timer 等。由于Reactor 模式一般使用在网络编程中，因而这里一
般指Socket Handle，即一个网络连接。
2）Synchronous Event Demultiplexer（同步事件复用器）：阻塞等待一系列的Handle 中
的事件到来，如果阻塞等待返回，即表示在返回的Handle 中可以不阻塞的执行返回的事件类型。
这个模块一般使用操作系统的select 来实现。
3）Initiation Dispatcher：用于管理Event Handler，即EventHandler 的容器，用以注
册、移除EventHandler 等；另外，它还作为Reactor 模式的入口调用Synchronous Event
Demultiplexer 的select 方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle
将其分发给对应的Event Handler 处理，即回调EventHandler 中的handle_event()方法。
4）Event Handler：定义事件处理方法：handle_event()，以供InitiationDispatcher 回
调使用。
5）Concrete Event Handler：事件EventHandler 接口，实现特定事件处理逻辑。

### select，poll，epoll的区别**，**原理，性能，限制

select
select：是最初解决IO 阻塞问题的方法。用结构体fd_set 来告诉内核监听多个文件描述符，
该结构体被称为描述符集。由数组来维持哪些描述符被置位了。对结构体的操作封装在三个宏定
义中。通过轮寻来查找是否有描述符要被处理。
存在的问题：

1. 内置数组的形式使得select 的最大文件数受限与FD_SIZE；
2. 每次调用select 前都要重新初始化描述符集，将fd 从用户态拷贝到内核态，每次调用
   select 后，都需要将fd 从内核态拷贝到用户态；
3. 轮寻排查当文件描述符个数很多时，效率很低；
   3、poll
   poll：通过一个可变长度的数组解决了select 文件描述符受限的问题。数组中元素是结构
   体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只
   需要拷贝一次到内核态。poll 解决了select 重复初始化的问题。轮寻排查的问题未解决。
   4、epoll
   epoll：轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll 采用
   只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。

  

  epoll 对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT
  模式是默认模式

1. LT 模式

```
LT(level triggered)是缺省的工作方式，并且同时支持block 和no-block socket.在这种
做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd 进行IO 操作。如
果你不作任何操作，内核还是会继续通知你的。
```

2. ET 模式
   ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符
   从未就绪变为就绪时，内核通过epoll 告诉你。然后它会假设你知道文件描述符已经就绪，并且
   不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为
   就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一
   个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd 作IO 操作(从而导致它再次变成未
   就绪)，内核不会发送更多的通知(only once)
   ET 模式在很大程度上减少了epoll 事件被重复触发的次数，因此效率要比LT 模式高。epoll
   工作在ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作
   把处理多个文件描述符的任务饿死。
   3、LT 模式与ET 模式的区别如下：
   LT 模式：当epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不
   立即处理该事件。下次调用epoll_wait 时，会再次响应应用程序并通知此事件。
   ET 模式：当epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立
   即处理该事件。如果不处理，下次调用epoll_wait 时，不会再次响应应用程序并通知此事件。





### **C++11有哪些新特性**

C++11 最常用的新特性如下：
auto 关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类
型的推导
nullptr 关键字：nullptr 是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；
而NULL 一般被宏定义为0，在遇到重载时可能会出现问题。
智能指针：C++11 新增了std::shared_ptr、std::weak_ptr 等类型的智能指针，用于解决
内存管理的问题。
初始化列表：使用初始化列表来对类进行初始化
右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象
拷贝，节省运算存储资源，提高效率
atomic 原子操作用于多线程资源互斥操作
新增STL 容器array 以及tuple



 32位编译器：

​      char ：1个字节
​       **char\***（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）
​       short int : 2个字节
​       int：  4个字节
​       unsigned int : 4个字节
​       float:  4个字节
​       double:   8个字节
​       **long**:   4个字节
​       long long:  8个字节
​       **unsigned long**:  4个字节

  64位编译器：

​      char ：1个字节
​       **char\***(即指针变量): 8个字节
​       short int : 2个字节
​       int：  4个字节
​       unsigned int : 4个字节
​       float:  4个字节
​       double:   8个字节
​       long:   8个字节
​       long long:  8个字节
​       unsigned long:  8个字节

 

/*考察结构体对齐和填充：

结构体每个成员相对于结构体的**首地址的**偏移量都是成员大小的整数倍，如果不是，编译器会自动在成员间填充。*/

struct A {

int a;                            //4 bytes

char b;                        //1 bytes

//char pad[3]               //3 bytes

int c;                           //4 bytes

char d;                       //1 bytes

//char pad[3]              //3 bytes

}                            // total = 16 bytes

 

/* P中有结构体A的成员，但是计算时按照A中数据类型确定的*/

struct P {
 struct A w[2];    // 2 * 16 bytes

short b;            //2 bytes

//char pad[2]    //2 bytes

struct A* p;      //4 bytes
 }  // total = 40 bytes

 

32位系统中指针变量4字节，另外，当所有成员大小计算完毕后，编译器判断当前结构体大小是否是结构体中最宽的成员变量大小的整数倍 如果不是会在最后一个成员后做字节填充，可以解释最后补充的字节。

总结就是，成员间填充，结构体填充。

 

```
define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。const常量会在内存中分配(可以是堆中也可以是栈中)
const定义的常量在程序运行过程中只有一份拷贝，但#define定义的常量在预编译阶段就被替换，程序运行时不存在变量拷贝。
 
栈向下生长，堆向上生长（高到低，低到高，假想栈区在高，堆区在低）
```



堆和栈的区别：**

·      1> 堆空间的内存是动态分配的,一般存放对象,并且需要手动释放内存。需要程序员自己申请并且指明大小，如C语言的malloc函数。

·      2> 栈空间的内存由系统自动分配,一般存放局部变量等,不需要手动管理内存。例如声明函数中的一个局部变量int b，系统在栈中自动为b开辟空间。

接下来我将从以下几个方面来阐述堆与栈的区别；

​    **管理方式****:**

​        对于栈来讲,由编译器自动管理,无需我们手动控制。

​        对于堆来说,释放工作由程序员控制,容易产生memory warning。

​    **申请大小****:**

​        栈:在Windows下,栈是向低地址扩展的数据结构,是一块连续的内存区域.即栈顶的地址和栈的最大容量是系统预先规好的。栈的大小是1M,如果申请空间超过栈的剩余空间时,将提示overflow.因此,能从栈获得的空间较小。

​        堆:堆是向高地址扩展的数据结构,是不连续的内存区域.这是因为系统是用链表来存储空闲内存地址的,自然是不连续的,而链表的遍历方向是由低地址向高地址.堆得大小受限于计算机系统中有效地虚拟内存.由此可见,堆获得的空间比较灵活,也比较大。

​    **碎片问题****:**

​        对于堆来讲,频繁的new/delete势必会造成内存空间的不连续,从而造成大量的碎片,使程序效率降低。

​        对于栈来讲,则不会存在这个问题,因为栈是先进后出得队列,它们是如此的一一对应,以至于永远都不可能有一个内存块从栈中间弹出。

​    **分配方式****:**

​        堆都是动态分配的,没有静态分配的堆。

​        栈有两种分配方式:静态分配和动态分配.静态分配是编译器完成的,比如局部变量的分配.动态分配由alloc函数进行分配,但是栈的动态分配和堆是不同的,它的动态分配是由编译器进行释放,无需我们手工实现。

​    **分配效率****:**

​        栈是机器系统提供的数据结构,计算机会在底层对栈提供支持:分配专门的寄存器存放栈的地址,压栈出栈都有专门的指令执行,这就决定了栈的效率比较高。

​        堆则是C/C++函数库提供的,它的机制是很复杂的。

 





### 面向对象基础</span>

能够准确理解下面这些问题是从C程序员向C++程序员进阶的基础。当然了，这只是一部分。

1. 面向对象三大特性？

   - 封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。
   - 继承性：让某种类型对象获得另一个类型对象的属性和方法。
   - 多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。

2. public/protected/private的区别？

   - public的变量和函数在类的内部外部都可以访问。
   - protected的变量和函数只能在类的内部和其派生类中访问。
   - private修饰的元素只能在类内访问。

3. 对象存储空间？

   - 非静态成员的数据类型大小之和。
   - 编译器加入的额外成员变量（如指向虚函数表的指针）。
   - 为了边缘对齐优化加入的padding。

4. C++空类有哪些成员函数?

   - 首先，空类大小为1字节。
   - 默认函数有：
     - 构造函数
     - 析构函数
     - 拷贝构造函数
     - 赋值运算符

5. 构造函数能否为虚函数，析构函数呢？

   - 析构函数：
     - 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。
     - 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。
     - 析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。
   - 构造函数：
     - 构造函数不能定义为虚函数。在构造函数中可以调用虚函数，不过此时调用的是正在构造的类中的虚函数，而不是子类的虚函数，因为此时子类尚未构造好。

6. 构造函数调用顺序，析构函数呢？

   - 调用所有虚基类的构造函数，顺序为从左到右，从最深到最浅
   - 基类的构造函数：如果有多个基类，先调用纵向上最上层基类构造函数，如果横向继承了多个类，调用顺序为派生表从左到右顺序。
   - 如果该对象需要虚函数指针(vptr)，则该指针会被设置从而指向对应的虚函数表(vtbl)。
   - 成员类对象的构造函数：如果类的变量中包含其他类（类的组合），需要在调用本类构造函数前先调用成员类对象的构造函数，调用顺序遵照在类中被声明的顺序。
   - 派生类的构造函数。
   - 析构函数与之相反。

7. 拷贝构造函数中深拷贝和浅拷贝区别？

   - 深拷贝时，当被拷贝对象存在动态分配的存储空间时，需要先动态申请一块存储空间，然后逐字节拷贝内容。
   - 浅拷贝仅仅是拷贝指针字面值。
   - 当使用浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针。因为所指向的内存空间已经被释放了。

8. 拷贝构造函数和赋值运算符重载的区别？

   - 拷贝构造函数是函数，赋值运算符是运算符重载。

   - 拷贝构造函数会生成新的类对象，赋值运算符不能。

   - 拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。

   - 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现"="的地方都是使用赋值运算符，如下：

     ```
     Student s;
     Student s1 = s;    // 调用拷贝构造函数
     Student s2;
     s2 = s;    // 赋值运算符操作
     ```

   **注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符**

9. 虚函数和纯虚函数区别？

   - 虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。
   - 纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。

10. 覆盖、重载和隐藏的区别？

    - 覆盖是派生类中重新定义的函数，其函数名、参数列表（个数、类型和顺序）、返回值类型和父类完全相同，只有函数体有区别。派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。覆盖只能发生在类的成员函数中。
    - 隐藏是指派生类函数屏蔽了与其同名的函数，这里仅要求基类和派生类函数同名即可。其他状态同覆盖。可以说隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。
    - 重载是具有相同函数名但参数列表不同（个数、类型或顺序）的两个函数（不关心返回值），当调用函数时根据传递的参数列表来确定具体调用哪个函数。重载可以是同一个类的成员函数也可以是类外函数。

11. 在main执行之前执行的代码可能是什么？

    - 全局对象的构造函数。

12. 哪几种情况必须用到初始化成员列表？

    - 初始化一个const成员。
    - 初始化一个reference成员。
    - 调用一个基类的构造函数，而该函数有一组参数。
    - 调用一个数据成员对象的构造函数，而该函数有一组参数。

13. 什么是虚指针？

    - 虚指针或虚函数指针是虚函数的实现细节。
    - 虚指针指向虚表结构。

14. 重载和函数模板的区别？

    - 重载需要多个函数，这些函数彼此之间函数名相同，但参数列表中参数数量和类型不同。在区分各个重载函数时我们并不关心函数体。
    - 模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表。但只适用于参个数相同而类型不同的函数。

15. this指针是什么？

    - this指针是类的指针，指向对象的首地址。
    - this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。
    - this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。

16. 类模板是什么？

    - 用于解决多个功能相同、数据类型不同的类需要重复定义的问题。
    - 在建立类时候使用template及任意类型标识符T，之后在建立类对象时，会指定实际的类型，这样才会是一个实际的对象。
    - 类模板是对一批仅数据成员类型不同的类的抽象，只要为这一批类创建一个类模板，即给出一套程序代码，就可以用来生成具体的类。

17. 构造函数和析构函数调用时机？

    - 全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。
    - 局部自动对象：建立对象时调用构造函数，离开作用域时调用析构函数。
    - 动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。
    - 静态局部变量对象：建立时调用一次构造函数，主函数结束时调用析构函数。

 