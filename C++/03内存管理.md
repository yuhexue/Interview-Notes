### C++内存管理

　在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。　

　　栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

　　堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

　　自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。

　　全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

​        常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

### C++内存分配

内存分配方式有三种：

（1）从全局/静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。

（2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率高但内存容量有限。

（3）从堆上分配，亦称动态内存分配。这里不对自由存储区（mallocfree）和堆(newdelete)做区分。程序在运行的时候用malloc或new申请任意多少的内存，程序员负责释放内存。生存期由程序员决定，如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

### 堆和栈的区别：

堆是动态分配的,需要手动释放内存。栈由系统自动分配,不需要手动管理内存。

从以下几个方面来阐述堆与栈的区别；

####   管理方式

​        对于栈来讲,由编译器自动管理,无需我们手动控制。

​        对于堆来说,释放工作由程序员控制,容易产生memory warning。

####   申请大小

​        栈:栈是向低地址扩展的数据结构,是一块连续的内存区域.即栈顶的地址和栈的最大容量是系统预先规好的。栈的大小是1M,如果申请空间超过栈的剩余空间时,将提示overflow.因此,能从栈获得的空间较小。

​        堆:堆是向高地址扩展的数据结构,是不连续的内存区域.这是因为系统是用链表来存储空闲内存地址的,自然是不连续的,而链表的遍历方向是由低地址向高地址.堆得大小受限于计算机系统中有效地虚拟内存.由此可见,堆获得的空间比较灵活,也比较大。

####    碎片问题

​        对于堆来讲,频繁的new/delete势必会造成内存空间的不连续,从而造成大量的碎片,使程序效率降低。

​        对于栈来讲,则不会存在这个问题,因为栈是先进后出得队列,它们是如此的一一对应,以至于永远都不可能有一个内存块从栈中间弹出。

####    分配方式

​        堆都是动态分配的,没有静态分配的堆。

​        栈有两种分配方式:静态分配和动态分配.静态分配是编译器完成的,比如局部变量的分配.动态分配由alloc函数进行分配,但是栈的动态分配和堆是不同的,它的动态分配是由编译器进行释放,无需我们手工实现。

####   分配效率

​        栈是机器系统提供的数据结构,计算机会在底层对栈提供支持:分配专门的寄存器存放栈的地址,压栈出栈都有专门的指令执行,这就决定了栈的效率比较高。

​        堆则是C/C++函数库提供的,它的机制是很复杂的。

### 堆和栈的区别（简答）：

堆是由低地址向高地址扩展；栈是由高地址向低地址扩展
堆中的内存需要手动申请和手动释放；栈中内存是由OS 自动申请和自动释放，存放着参数、局部变量等内存
堆中频繁调用malloc 和free,会产生内存碎片，降低程序效率；而栈由于其先进后出的特性，不会产生内存碎片
堆的分配效率较低，而栈的分配效率较高

程序局部变量是使用的栈空间，new/malloc 动态申请的内存是堆空间，函数调用时会进
行形参和返回值的压栈出栈，也是用的栈空间。

### 栈的效率高的原因：

栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而堆是由C/C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。

### 栈溢出概念：

栈溢出指程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与该变量相邻的变量的值被改变。

栈溢出的原因：
	1.局部数组过大。当函数内部的数组过大时，有可能导致栈溢出。局部变量是存储在栈中的，解决这类问题的办法有两个，一是增大栈空间，二是改用动态分配，使用堆（heap）而不是栈（stack）。

​	2.递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致栈溢出。

​	3.指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。

```C++
int main(int argc, char* argv[]) {
    char buf[256];
    strcpy(buf,argv[1]);
    printf("Input:%s\n",buf);
    return 0;
}
```

上述代码中的strcpy(buf,argv[1]);这一行发生了缓冲区溢出错误，因为源缓冲区内容是用户输入的。

### 内存分配函数

#### malloc、calloc、realloc、alloca

1. malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。
2. calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。
3. realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。
4. alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。

#### malloc、free


申请内存，确认是否申请成功，释放内存后指针置空

```cpp
char *str = (char*) malloc(100);
assert(str != nullptr);
free(p); 
p = nullptr;
```

#### new、delete

1. new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。
2. delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。
3. new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。

```c++
int main()
{
    T* t = new T();     // 先内存分配 ，再构造函数
    delete t;           // 先析构函数，再内存释放
    return 0;
}
```

### new/delete与malloc/free的区别和实现

首先，new/delete 是C++的关键字，而malloc/free 是C 语言的库函数，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数

malloc 需要给定申请内存的大小，返回的指针需要强转。
new 会调用构造函数，不用指定内存大小，返回的指针不用强转。

1、new 分配内存按照数据类型进行分配，malloc 分配内存按照指定的大小分配；
2、new 返回的是指定对象的指针，而malloc 返回的是void*，因此malloc 的返回值一般都需要进行类型转化。
3、new 不仅分配一段内存，而且会调用构造函数，malloc 不会。
4、new 分配的内存要用delete 销毁，malloc 要用free 来销毁；delete 销毁的时候会调用对象的析构函数，而free 则不会。
5、new 是一个操作符可以重载，malloc 是一个库函数。
6、malloc 分配的内存不够的时候，可以用realloc 扩容。扩容的原理？new 没用这样操作。
7、new 如果分配失败了会抛出bad_malloc 的异常，而malloc 失败了会返回NULL。
8、申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc 则只能sizeof(int) * n。

https://www.cnblogs.com/ywliao/articles/8116622.html

### 如何定义一个只能在堆上（栈上）生成对象的类？

#### 只能在堆上

方法：将析构函数设置为私有

原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。

#### 只能在栈上

方法：将 new 和 delete 重载为私有

原因：在堆上生成对象要使用 new ，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。

更详细的解释：

[如何定义一个只能在堆上（栈上）生成对象的类?](https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618)

### c++怎么定义常量，常量放在什么位置

常量定义必须初始化。对于局部对象，常量存放在栈区，对于全局对象，常量存放在全局/静态存储区。对于字面值常量，常量存放在常量存储区。

