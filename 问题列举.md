同步：线程自己等待IO完成（不管非阻塞等待还是阻塞等待，强调自己等待完成）
异步：强调别的线程等待完成或者内核等待完成，然后回调
阻塞：数据未准备好前是一直阻塞
非阻塞：数据未准备好时会立即返回，并轮询。

epoll实际上只是通过多路事件分离器分离事件，起到的仅仅是告知某个文件描述符可以读写了，也就是说epoll并不具有区别同步、异步的属性，区别还是得看产生I/O的线程是如何做的。


Reactor和proactor的通俗解释:
以读操作为例：
角色分工 
顾客：读就绪事件 厨师：事件处理器 传话员：事件分离器 代工：内核
Reactor:注册读就绪事件和事件处理器，分离器等待读就绪事件发生，有读就绪事件发生（有人点餐），事件分离器通知事件处理器，事件处理器进行读取操作并处理（记录要吃啥并做好）
Proactor:注册异步读取事件和事件处理器，分离器等待读完成事件发生，有读就绪事件发生（有人点餐），内核去读取（记录吃啥），并复制给线程缓存区，通知事件分离器，给到处理器，事件处理器不用做读取操作（），只处理。

区别：读就绪事件未到来，re要等，pro不等，让内核通知，所以sre同步，要等待就绪。Pro异步，不用自己等待读就绪，是由内核读取并通知。Pro关注读完成，且内核读取并给到线程缓存区。

https://blog.csdn.net/caiwenfeng_for_23/article/details/8458299





线程池的设计：生产者和消费者







```C++
#include <sys/epoll.h>
int epoll_create1(int flags);
功能：创建一个多路复用的实例
参数：
flags：
0:如果这个参数是0，这个函数等价于poll_create（0）
EPOLL_CLOEXEC：这是这个参数唯一的有效值，如果这个参数设置为这个。那么当进程替换映像的时候会关闭这个文件描述符，这样新的映像中就无法对这个文件描述符操作，适用于多进程编程+映像替换的环境里
返回值：
success：返回一个非0 的未使用过的最小的文件描述符
error：-1 errno被设置

--------------------------------------------------------------------

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
功能：操作一个多路复用的文件描述符
参数：
epfd：epoll_create1的返回值
op：要执行的命令
EPOLL_CTL_ADD：向多路复用实例加入一个连接socket的文件描述符
EPOLL_CTL_MOD：改变多路复用实例中的一个socket的文件描述符的触发事件
EPOLL_CTL_DEL：移除多路复用实例中的一个socket的文件描述符
fd：要操作的socket的文件描述符
event：
typedef union epoll_data {
               void        *ptr;
               int          fd;
               uint32_t     u32;
               uint64_t     u64;
           } epoll_data_t;

struct epoll_event {
               uint32_t     events;      /* Epoll events */
               epoll_data_t data;        /* User data variable */
};
events可以是下列命令的任意按位与
EPOLLIN：对应的文件描述有可以读取的内容
EPOLLOUT：对应的文件描述符有可以写入
EPOLLRDHUP：写到一半的时候连接断开
EPOLLPRI：发生异常情况，比如所tcp连接中收到了带外消息
EPOLLET：设置多路复用实例的文件描述符的事件触发机制为边沿触发，默认为水平触发
1、当多路复用的实例中注册了一个管道，并且设置了触发事件EPOLLIN，
2、管道对端的写入2kb的数据，
3、epoll_wait收到了一个可读事件，并向上层抛出，这个文件描述符
4、调用者调用read读取了1kb的数据，
5、再次调用epoll_wait


边沿触发：上面的调用结束后，在输入缓存区中还有1kb的数据没有读取，但是epoll_wait将不会再抛出文件描述符。这就导致接受数据不全，对端得不到回应，可能会阻塞或者自己关闭
因为边沿触发的模式下，只有改变多路复用实例中某个文件描述符的状态，才会抛出事件。
相当于，边沿触发方式，内核只会在第一次通知调用者，不管对这个文件描述符做了怎么样的操作

水平触发：
只要文件描述符处于可操作状态，每次调用epoll_wait，内核都会通知你

EPOLLONESHOT：epoll_wait只会对该文件描述符第一个到达的事件有反应，之后的其他事件都不向调用者抛出。需要调用epoll_ctl函数，对它的事件掩码重新设置
EPOLLWAKEUP
EPOLLEXCLUSIVE
返回值：
success：0
error：-1 errno被设置

--------------------------------------------------------------------

int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);
功能：等待一个epoll队列中的文件描述符的I/O事件发生
参数：
epfd：目标epoll队列的描述符
events：用于放置epoll队列中准备就绪（被触发）的事件
maxevents：最大事件？
timeout：指定函数等待的时间。这个函数阻塞这么长一段时间之后接触阻塞。
返回值：
>=0，表示准备就绪的文件描述符个数
-1：出错，errno被设置

```

https://blog.csdn.net/qq_34802511/article/details/81543817

https://www.cnblogs.com/pang1567/p/4057375.html



session和cookie的区别和联系

https://www.cnblogs.com/endlessdream/p/4699273.html



为什么MySQL数据库索引选择使用B+树？（总结的很好）

https://www.cnblogs.com/tiancai/p/9024351.html



1. 错误码 / errno
  Linux中系统调用的错误都存储于 errno中，errno由操作系统维护，存储就近发生的错误，即下一次的错误码会覆盖掉上一次的错误。




循环处理流程里的细节：如边沿触发

线程池，简单来说就是有一堆已经创建好的线程（最大数目一定），初始时他们都处于空闲状态，当有新的任务进来，从线程池中取出一个空闲的线程处理任务，然后当任务处理完成之后，该线程被重新放回到线程池中，供其他的任务使用，当线程池中的线程都在处理任务时，就没有空闲线程供使用，此时，若有新的任务产生，只能等待线程池中有线程结束任务空闲才能执行，
使用互斥锁虽然可以解决一些资源竞争的问题，但互斥锁只有两种状态（加锁和解锁），这限制了互斥锁的用途。



条件变量（条件锁）也可以解决线程同步和共享资源访问的问题，条件变量是对互斥锁的补充，它允许一个线程阻塞并等待另一个线程发送的信号，当收到信号时，阻塞的线程被唤醒并试图锁定与之相关的互斥锁。



线程池可以说是项目中经常会用到的组件，在这里假设读者都有一定的多线程基础，如果没有的话不妨在这里进行了解：POSIX 多线程基础。

线程池是什么？我的简单理解是有一组预先派生的线程，然后有一个管理员来管理和调度这些线程，你只需不断把需要完成的任务交给他，他就会调度线程的资源来帮你完成。

那么管理员是怎么做的呢？一种简单的方式就是，管理员管理一个任务的队列，如果收到新的任务，就把任务加到队列尾。每个线程盯着队列，如果队列非空，就去队列头拿一个任务来处理（每个任务只能被一个线程拿到），处理完了就继续去队列取任务。如果没有任务了，线程就休眠，直到任务队列不为空。如果这个管理员更聪明一点，他可能会在没有任务或任务少的时候减少线程的数量，任务处理不过来的时候增加线程的数量，这样就实现了资源的动态管理。
立刻结束指不管任务队列是否为空，立刻结束。平和结束指等待任务队列的任务全部执行完后再结束，在这个过程中不可以添加新的任务。



线程操纵函数（省略参数）
pthread_create	创建一个线程
pthread_exit	终止当前线程
pthread_cancel	中断另外一个线程的运行
pthread_join	阻塞当前的线程，直到另外一个线程运行结束
pthread_attr_init	初始化线程的属性
pthread_attr_setdetachstate	设置脱离状态的属性（决定这个线程在终止时是否可以被结合）
pthread_attr_getdetachstate	获取脱离状态的属性
pthread_attr_destroy	删除线程的属性
pthread_kill	向线程发送一个终止信号
同步函数
用于 mutex 和条件变量
pthread_mutex_init	初始化互斥锁
pthread_mutex_destroy	删除互斥锁
pthread_mutex_lock	占有互斥锁（阻塞操作）
pthread_mutex_trylock	试图占有互斥锁（不阻塞操作）。当互斥锁空闲时将占有该锁；否则立即返回　
pthread_mutex_unlock	释放互斥锁
pthread_cond_init	初始化条件变量
pthread_cond_destroy	销毁条件变量
pthread_cond_wait	等待条件变量的特殊条件发生
pthread_cond_signal	唤醒第一个调用pthread_cond_wait()而进入睡眠的线程

函数定义： int pthread_join(pthread_t thread, void **retval);
描述 ：pthread_join()函数，以阻塞的方式等待thread指定的线程结束。当函数返回时，被等待线程的资源被收回。
pthread_exit()函数  //终止当前线程
互斥锁一个明显的缺点是它只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，它常和互斥锁一起配合使用。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。一般说来，条件变量被用来进行线程间的同步。
两个线程操作同一临界区时，通过互斥锁保护，若A线程已经加锁，B线程再加锁时候会被阻塞，直到A释放锁，B再获得锁运行，进程B必须不停的主动获得锁、检查条件、释放锁、再获得锁、再检查、再释放，一直到满足运行的条件的时候才可以（而此过程中其他线程一直在等待该线程的结束），这种方式是比较消耗系统的资源的。而条件变量同样是阻塞，还需要通知才能唤醒，线程被唤醒后，它将重新检查判断条件是否满足，如果还不满足，该线程就休眠了，应该仍阻塞在这里，等待条件满足后被唤醒，节省了线程不断运行浪费的资源。这个过程一般用while语句实现。当线程B发现被锁定的变量不满足条件时会自动的释放锁并把自身置于等待状态，让出CPU的控制权给其它线程。其它线程 此时就有机会去进行操作，当修改完成后再通知那些由于条件不满足而陷入等待状态的线程。这是一种通知模型的同步方式，大大的节省了CPU的计算资源，减少了线程之间的竞争，而且提高了线程之间的系统工作的效率。这种同步方式就是条件变量。     
总结：
为了避免因条件判断语句与其后的正文或wait语句之间的间隙而产生的漏判或误判，所以用一个mutex来保证: 对于某个cond的包括(判断,修改)在内的任何有关操作某一时刻只有一个线程在访问。也就是说条件变量本身就是一个竞争资源，这个资源的作用是对其后程序正文的执行权，于是用一个锁来保护。
条件变量用于某个线程需要在某种条件成立时才去保护它将要操作的临界区，这种情况从而避免了线程不断轮询检查该条件是否成立而降低效率的情况，这是实现了效率提高。。。在条件满足时，自动退出阻塞，再加锁进行操作。
以上是关于效率问题，此外互斥锁还有一个缺点就是会造成死锁。
例如线程A和线程B都需要独占使用2个资源，但是他们都分别先占据了一个资源，然后又相互等待另外一个资源的释放，这样就形成了一个死锁。
条件变量起到了阻塞和唤醒线程的作用，所以通常互斥锁要和条件变量配合。
为了解决以上问题，条件变量常和互斥锁一起使用，条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其它的某个线程改变了条件变量，它将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。

互斥锁的不足：要么固定时间去等待，多费时间。要么不断跑线程去主动查询，耗费计算资源。
条件变量：本身是竞争资源，要加锁保护，该线程内条件不满足，释放锁，该线程阻塞。其他线程改变条件，唤醒该线程，该线程重新加锁，判条件。





1，从存储空间角度
	虚函数对应一个vtable，这大家都知道，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。
2，从使用角度
	虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。
虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。
也就是说：使用虚函数是为了创建对象后调用函数时多态，而构造函数是创建对象时自行调用的。目的不同。

扩展：内联函数在编译期，静态函数不属于类。
Malloc是库函数，new是运算符。New在创建一个对象时会调用对象的构造函数，如string类对象，自定义对象。而malloc只负责创建空间。另外返回值new是返回类对象的数据类型，malloc是返回void*类型，通过强转。
New是系统计算内存大小，malloc要sizeof（数据类型）*num



AVl树：平衡二叉查找树，在bst的基础上平衡。
红黑树：满足红黑几大要求的bst。调整：变色和旋转（左逆时针右顺时针）

相比于最简单的BST，BST最差情况下查找的时间复杂度会上升至O(n)，而红黑树最坏情况下查找效率依旧是O(logn)。所以说红黑树之所以能够在STL及Linux内核中被广泛应用就是因为其折中了两种方案，既减少了树高，又减少了建树时旋转的次数。
从红黑树的定义来看，红黑树从根到NULL的每条路径拥有相同的黑节点数（假设为n），所以最短的路径长度为n（全为黑节点情况）。因为红节点不能连续出现，所以路径最长的情况就是插入最多的红色节点，在黑节点数一致的情况下，最可观的情况就是黑红黑红排列......最长路径不会大于2n，这里路径长就是树高。

分而治之和hash映射

位图法就是bitmap的缩写。所谓bitmap，就是用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。通常是用来判断某个数据存不存在的。
Bitmap的使用样例：内部维护数组   char M [N];  //可最多记录数值从0到8*N的出现情况，每个bit记录一个数值是否出现。
4、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数
      参考的一个方法是：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）。其实，这里可以使用两个普 通的Bitmap，即第一个Bitmap存储的是整数是否出现，如果再次出现，则在第二个Bitmap中设置即可。这样的话，就可以使用简单的1- Bitmap了。




软链接和硬链接：
先讲三个概念：inode,文件名，文件数据
Inode和文件数据分开存储，文件名看作是inode的访问别名，inode包含文件的元信息（如文件大小，文件所有者，权限,多少个文件指向它，文件数据位置等等）
硬链接里，包含多个文件名（访问别名），同一个inode，删除一个硬链接只是inode里的文件指向减一，直至为0才删除文件数据。
软链接会生成不同的inode，但是软连接文件的文件内容是目标文件的路径，故可以跨文件系统，删除目标文件会使软连接无法再打开连接内容。类似于win的快捷方式。、


数据流和数据包：
在编程角度上：
结合TCP的概念，水池就好比接收缓存，倒水就相当于发送数据，接水就相当于读取数据。好比你通过TCP连接给另一端发送数据，你只调用了一次 write，发送了100个字节，但是对方可以分10次收完，每次10个字节;你也可以调用10次write，每次10个字节，但是对方可以一次就收完。 (假设数据都能到达)但是，你发送的数据量不能大于对方的接收缓存(流量控制)，如果你硬是要发送过量数据，则对方的缓存满了就会把多出的数据丢弃。

UDP和TCP不同，发送端调用了几次write，接收端必须用相同次数的read读完。UPD是基于报文的，在接收的时候，每次最多只能读取一个 报文，报文和报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。也就说，如果不指定MSG_PEEK标志，每次读取操作将消耗一个报文。

应用场景：若通信数据完整性需让位与通信实时性，则应该选用 TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。
长连接和短链接：
首先看两个概念： 
短连接： http1.0
连接->传输数据->关闭连接 

HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。 
也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。 

长连接： 
连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。 
长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。
粘包与分包 （半包）
指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。出现粘包现象的原因是多方面的，它既可能由发送方造成，也可能由接收方造成。发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。分包是指在出现粘包的时候我们的接收方要进行分包处理。

总结：粘包是一包连着一包，发送方会因单包数据太少而优化合并发送，接收方会因处理不及时导致缓冲区堆积连包数据。分包即接收的时候得到半包，a尾b头之类的。




超时重传、滑动窗口、拥塞控制、快重传和快恢复
超时重传：原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。 
滑动窗口：
概述
滑动窗口实现了TCP流控制。首先明确滑动窗口的范畴：TCP是双工的协议，会话的双方都可以同时接收和发送数据。TCP会话的双方都各自维护一个发送窗口和一个接收窗口。各自的接收窗口大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。各自的发送窗口则要求取决于对端通告的接收窗口，要求相同。

滑动窗口解决的是流量控制的的问题，就是如果接收端和发送端对数据包的处理速度不同，如何让双方达成一致。接收端的缓存传输数据给应用层，但这个过程不一定是即时的，如果发送速度太快，会出现接收端数据overflow，流量控制解决的是这个问题。
发送窗口只有收到对端对于本段发送窗口内字节的ACK确认，才会移动发送窗口的左边界。 接收端可以根据自己的状况通告窗口大小，从而控制发送端的接收，进行流量控制。
稳定：信息a到z，发送方只有收到ack才会发送下一个，接收方按现状态已收到的发送ack。
流控：调整窗口大小，避免溢出。

TCP拥塞控制
　　拥塞控制是一个全局性的过程； 流量控制是点对点通信量的控制 
　　TCP拥塞控制4个核心算法：慢开始（slow start）、拥塞避免（Congestion Avoidance）、快速重传（fast retransmit）、快速回复（fast recovery） 


慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。 

快重传算法规定，发送方只要一连收到3个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计数器时间到期。

对比滑动窗口和拥塞窗口
滑动窗口是控制接收以及同步数据范围的，通知发送端目前接收的数据范围，用于流量控制，接收端使用。拥塞窗口是控制发送速率的，避免发的过多，发送端使用。因为tcp是全双工，所以两边都有滑动窗口。 
两个窗口的维护是独立的，滑动窗口主要由接收方反馈缓存情况来维护，拥塞窗口主要由发送方的拥塞控制算法检测出的网络拥塞程度来决定的。


1.普遍认为：
当N很小时，快速排序慢，归并排序快 
当N很大时，并且有序程度高时，快速排序最快 
当N很大时，并且有序程序低时，堆排序最快

快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；
堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。
若要求排序稳定，则可选用归并排序。先利用直接插入排序求得较长的有序子文件，然后再两两归并之。因为直接插入排序是稳定的，所以改进后的归并排序仍是稳定的。

但是：由于快速排序不稳定，因此数据量极大时不如选用堆排序。



堆排序占花费是时间主要是在建堆的时候。
所以在数据量方面来说，如果数据量越大，堆排序的优势就越明显。
大多数商用软件都采用快排，因为它在一般情况下是排序最快的算法。
然而，快排绝不能用于需要特定响应时间的系统，除非这个系统能承受O(n^2)的时间复杂度。
如果你预先估计可能会碰到这种最坏情况，那么
如果n比较小，改用插入排序――由于代码简单，它的时间复杂度的常数项比较少
如果n比较大，改用堆排序――你应该用堆排序，因为它能保证O(nlogn)的时间复杂度.




https://www.cnblogs.com/George1994/p/7008732.html
https://blog.csdn.net/random__walker/article/details/52051556
b树（也叫b-树），b+树都是多路平衡树，平衡保证了查询的稳定，机械硬盘的转动和摆臂决定了硬件的耗时，所以要减少查找时对磁盘的IO操作。

B树上大部分的操作所需要的磁盘存取次数和B树的高度是成正比的，在B树中可以检查多个子结点，由于在一棵树中检查任意一个结点都需要一次磁盘访问，所以B树避免了大量的磁盘访问。

由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。

客户端发送SYN包A1,由于网络链路问题,到达时间滞后
因为客户端迟迟收不到服务器的响应,以为丢包,清理A1,重发SYN包B1
B1顺利到达,响应B2,与客户端建立连接
A1姗姗来迟,响应A2,由于A1被清理,客户端不理会A2
但是服务器还是会维持这个僵尸连接


原子性编辑
整个事务中的所有操作，要么全部完成，要么全部不完成，发生错误会回滚
一致性编辑
事务必须始终保持系统处于一致的状态.
隔离性编辑
隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。
使得在同一时间仅有一个请求用于同一数据。
持久性编辑
在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。










