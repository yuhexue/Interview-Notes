数组排列规律题：

差值：等差，增差，减差，变差

乘除：等比，增比，减比，幂方

0,5,27,119,495,2015，？

二进制与十进制之间转换
 0是0
 5是101
 27是11011
 119是1110111
 495是111101111
 2015是11111011111
 规律显而易见，1111110111111是8127

 

在0到1之间随机选择3个小数，他们的和小于1的概率是？

1/6,立方体切体积

 



鸡蛋掉落问题

https://github.com/Shellbye/Shellbye.github.io/issues/42 



### 给你两个球，100层楼，每个球在一定高度扔下去会碎，怎么用最少的次数给判断是几层楼能把求摔碎？ 





位图法就是bitmap的缩写。所谓bitmap，就是用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。通常是用来判断某个数据存不存在的。
Bitmap的使用样例：内部维护数组   char M [N];  //可最多记录数值从0到8*N的出现情况，每个bit记录一个数值是否出现。
4、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数
      参考的一个方法是：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）。其实，这里可以使用两个普 通的Bitmap，即第一个Bitmap存储的是整数是否出现，如果再次出现，则在第二个Bitmap中设置即可。这样的话，就可以使用简单的1- Bitmap了。



# 海量数据处理





### 海量数据求Top K 问题

1.直接全部排序（只适用于内存够的情况）
当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前K 个。
这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出top K个数据，所以该方法并不十分高效，不建议使用。
2.快速排序的变形（只使用于内存够的情况）
这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前K 个最大的就行。

这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index 刚好等于K，那么这个划分元以及它左边的数，刚好就是前K 个最大的元素；如果index > K，那么前K 大的数据在index 的左边，那么就继续递归的从index-1 个数中进行一趟排序；如果index< K，那么再从划分元的右边继续进行排序，直到找到序号index 刚好等于K 为止。再将前K 个数进行排序后，返回Top K 个元素。这种方法就避免了对除了Top K 个元素以外的数据进行排序所带来的不必要的开销。
3.最小堆法
这是一种局部淘汰法。先读取前K 个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K 个数。
4.分治法
将全部数据分成N 份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的K 个数。此时剩下N*K 个数据，如果内存不能容纳N*K 个数据，则再继续分治处理，分成M份，找出每份数据中最大的K 个数，如果M*K 个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。

5.Hash 法
如果这些数据中有很多重复的数据，可以先通过hash 法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。





https://blog.csdn.net/yangquanhui1991/article/details/52172768



### 第k大的数的方法以及各自的复杂度**是怎样的，另外追问一下，**当有相同元素时，还可以使用什么不同的方法求第k大的元素

首先使用快速排序算法将数组按照从大到小排序，然后取第k 个，其时间复杂度最快为O(nlogn)
使用堆排序，建立最大堆，然后调整堆，知道获得第k 个元素，其时间复杂度为O(n+klogn)
首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1 个数则为第k 大的数
利用快排思想，从数组中随机选择一个数i，然后将数组分成两部分Dl,Dr，Dl 的元素都小于i,Dr 的元素都大于i。然后统计Dr 元素个数，如果Dr 元素个数等于k-1,那么第k 大的数即为k，如果Dr 元素个数小于k,那么继续求Dl 中第k-Dr 大的元素；如果Dr 元素个数大于k,那么继续求Dr 中第k 大的元素。

当有相同元素的时候，
首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1 个数则为第k 大的数，平均情况下时间复杂度为O(n)

## TOP N问题 

1. 如何在海量数据中找出重复最多一个。

- 通过hash映射为小文件
- 通过hash_map统计各个小文件重读最多的并记录次数
- 对每个小文件重复最多的进行建立大根堆

2. 上亿有重数据，统计最多前N个。

- 内存存不下
  - 通过hash映射为小文件
  - 通过hash_map统计各个小文件重读最多的并记录次数
  - 对每个小文件重复最多的进行建立大根堆并重复N次取走堆顶并重建堆操作
- 内存存得下
  - 直接内存通过hash_map统计并建大根堆
  - 重复N次取走堆顶并重建堆操作

3. 海量日志数据，提取出某日访问百度次数最多的那个IP（同1）。

- 将IP % 1000映射到1000个小文件中
  - 相同IP会被映射到同一个文件
  - 不会出现累加和更大情况
- 分1000次在内存处理小文件，得到频率最大IP（使用map统计）
- 对这1000个IP建立大根堆

4. 1000w查询串统计最热门10个（同2）。

- 同上

5. 1G的文件，里面1行1个不超过16字节的词。内存限制1M，返回频数最高前100（同2）。

- 将单词 % 5000存入5000小文件
  - 平均各文件约200K
  - 对超过1M的文件继续分割直到小于200K
- 使用map统计各个词出现的频率
- 对5000词使用堆排序或归并排序

## 分布式TOP N问题

6. 分布在100台电脑的海量数据，统计前十。

- 各数据只出现在一台机器中
  - 先在独立机器得到前十
    - 若可以放入内存直接堆排序
    - 若不可全放入内存：哈希分块 -> map统计 -> 归总堆排
  - 再将100台计算机的TOP10组合起来堆排序
- 同一元素可同时出现在不同机器中
  - 遍历所有数据，重新hash取模，使同一个元素只出现在单独的一台电脑中，然后采用上面方法先统计每台电脑TOP10再汇总起来

## 快速外排序问题

7. 有10个1G文件，每行都是一个可重复用户query，按query频度排序。

- 顺序读取十个文件并采取哈希，将query写入10个文件中
- 通过hash_map(query, count)统计每个query出现次数，至少2G内存
- 通过得到的hash_map中query和query_count，对query_count排序并将重新输出到文件中，得到已排序好的文件
- 对十个文件进行归并排序（外排序）

## 公共数据问题

8. A,B两个文件各存放50亿url，每个为64Byte，限制内存4G找出公共url。

- 对A和B两个大文件，先通过url % 1000将数据映射到1000个文件中，单个文件大小约320M（我们只需要检查对应小文件A1 V B1......，不对应小文件不会有相同url）
- 通过hash_set统计，把A1的url存储到hash_set中，再遍历对应的B1小文件，检查是否在hash_set中，若存在则写入外存。重复循环处理对应的1000个对。

9. 1000w有重字符串，对字符串去重。

- 先hash分为多个文件
- 逐个文件检查并插入set中
- 多个set取交集

## 内存内TOP N问题

10. 100w个数字找出最大100个。

- 堆排序法
  - 建大根堆，取走堆顶并重建堆，重复100次
- 快排法
  - 使用快速排序划分，若某次枢纽元在后10000时（具体情况具体分析），对后10000数据排序后取前100

## 位图法

11. 在2.5亿数字中找出不重复的整数。

- 使用2-Bit位图法，00表示不存在，01表示出现一次，10表示出现多次，11无意义。这样只需要1G内存。
- 或者hash划分小文件，小文件使用hash_set检查各个元素，得到的。

12. 如何在40亿数字中快速判断是否有某个数？

- 位图法标记某个数字是否存在，check标记数组。







数组排列规律题：

差值：等差，增差，减差，变差

乘除：等比，增比，减比，幂方

0,5,27,119,495,2015，？

二进制与十进制之间转换
 0是0
 5是101
 27是11011
 119是1110111
 495是111101111
 2015是11111011111
 规律显而易见，1111110111111是8127

 

在0到1之间随机选择3个小数，他们的和小于1的概率是？

1/6,立方体切体积