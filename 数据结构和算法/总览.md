## 基础概念：

### Array&List的区别 


内存是否连续，关系到随机读取效率。

查找数据，插入数据和删除数据。

数组需要预留空间，不利于扩展。

### 树

#### 树分类

- 满二叉树：每层都满

- 完全二叉树：只能最后一层不满，且靠左

- 二叉查找树（二叉排序树）：所有左 < 根 < 所有右（没有键值相等的点）

- 平衡二叉树：高度平衡的二叉树，具体包括如AVL树，红黑树，这两种都是常用的平衡二叉搜索树。

  严格意义上的高度平衡是差值<=1，如AVL，但是红黑树是大致高度平衡，而不严格意义限制。

- B树及其变种

- 字典树（Trie树）

#### 二叉查找树

n个节点的插入和查找、删除的平均时间复杂度均为O(logn)，最坏的情况下O(n)。

二叉查找树的高度决定了二叉查找树的查找效率。

#### 平衡二叉树之AVL树

n个节点的插入和查找、删除的平均时间复杂度和最差情况均为O(logn)。

增加和删除可能需要一次或多次树旋转来重新平衡这个树。频繁旋转会使插入和删除牺牲掉O(logN)左右的时间。

#### 平衡二叉树之红黑树

##### 红黑树的特征是什么？

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是 NIL 节点）。
4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同）
5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红）

##### 调整

1. 变色
2. 左旋
3. 右旋

##### 应用

- 关联数组：如 STL 中的 map、set

#### B 树及其变种

B树是一种多路搜索树，一般用于数据库系统和文件系统。B+树是B树的变种，B*树是B+树的变种。

##### 特点

- 一般化的二叉查找树（binary search tree）
- “矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）

##### 应用

- 大部分文件系统、数据库系统都采用B树、B+树作为索引结构

##### 区别

- B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。
- B+树中所有叶子节点都是通过指针连接在一起，而B树不会。

##### B树的优点

对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。

##### B+树的优点

- 非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。
- 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。

> B 树、B+ 树区别来自：[differences-between-b-trees-and-b-trees](https://stackoverflow.com/questions/870218/differences-between-b-trees-and-b-trees)、[B树和B+树的区别]

　　在B树中查找给定关键字的方法是，首先把根结点取来，在根结点所包含的关键字K1,…,Kn查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，Pi为指向子树根节点的指针，此时取指针Pi所指的结点继续查找，直至找到，或指针Pi为空时查找失败。

##### 红黑树、B 树、B+ 树的区别？

- 红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些
- B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。

### 红黑树和AVL树以及BST树的定义，特点，以及二者区别 

平衡二叉树（AVL 树）：
平衡二叉树又称为AVL 树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。一句话表述为：以树中所有结点为根的树的左右子树高度之差的绝对值不超过1。将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0 和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。
红黑树：
红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL 树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。

性质：
1. 每个节点非红即黑
2. 根节点是黑的;
3. 每个叶节点（叶节点即树尾端NULL 指针或NULL 节点）都是黑的;
4. 如果一个节点是红色的，则它的子节点必须是黑色的。
5. 对于任意节点而言，其到叶子点树NULL 指针的每条路径都包含相同数目的黑节点;

区别：
AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。

2、平衡二叉树（AVL 树）：
红黑树是在AVL 树的基础上提出来的。
平衡二叉树又称为AVL 树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。
AVL 树中所有结点为根的树的左右子树高度之差的绝对值不超过1。将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的
所有结点的平衡因子只可能是-1、0 和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。

3、红黑树较AVL 树的优点：
AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。
所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL 里面很多结构包括map 底层实现都是使用的红黑树。

### 红黑树的性质还有左右旋转 （10题）

1）平衡二叉树（AVL 树）：
红黑树是在AVL 树的基础上提出来的。
平衡二叉树又称为AVL 树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。
AVL 树中所有结点为根的树的左右子树高度之差的绝对值不超过1。
将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0 和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。
2）红黑树：
红黑树是在AVL 树的基础上发展而来的。红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL 树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。
性质：

1. 每个节点非红即黑
2. 根节点是黑的;
3. 每个叶节点（叶节点即树尾端NULL 指针或NULL 节点）都是黑的;
4. 如果一个节点是红色的，则它的子节点必须是黑色的。
5. 对于任意节点而言，其到叶子点树NULL 指针的每条路径都包含相同数目的黑节点;
   从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。恢复红黑属性需要少量(O(log n))的颜色变更(这在实践中是非常快速的)并且不超过三次树旋转(对于插入是两次)。这允许插入和删除保持为O(log n) 次，

https://www.cnblogs.com/maybe2030/p/4732377.html

### map底层为什么用红黑树实现 

红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL 树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。

### map和u**nordered_map**的**底层实现** ，优点和缺点 

map 底层是基于红黑树实现的，因此map 内部元素排列是有序的。而unordered_map 底层则是基于哈希表实现的，因此其元素的排列顺序是杂乱无序的。

对于map，其底层是基于红黑树实现的，优点如下：
1)有序性，这是map 结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作
2)map 的查找、删除、增加等一系列操作时间复杂度稳定，都为logn
缺点如下：
1）查找、删除、增加等操作平均时间复杂度较慢，与n 相关
对于unordered_map 来说，其底层是一个哈希表，优点如下：
查找、删除、添加的速度快，时间复杂度为常数级O(c)
缺点如下：
因为unordered_map 内部基于哈希表，以（key,value）对的形式存储，因此空间占用率高
Unordered_map 的查找、删除、添加的时间复杂度不稳定，平均为O(c)，取决于哈希函数。
极端情况下可能为O(n)。

### **哈夫曼编码** 

哈夫曼编码是哈夫曼树的一种应用，广泛用于数据文件压缩。哈夫曼编码算法用字符在文件中出现的频率来建立使用0，1 表示个字符的最优表示方式，其具体算法如下：
(1)哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树T。
(2)算法以|C|个叶结点开始，执行|C|－1 次的“合并”运算后产生最终所要求的树T。
(3)假设编码字符集中每一字符c 的频率是f(c)。以f 为键值的优先队列Q 用在贪心选择时有效地确定算法当前要合并的2 棵具有最小频率的树。一旦2 棵具有最小频率的树合并后，产生一棵新的树，其频率为合并的2 棵树的频率之和，并将新树插入优先队列Q。经过n－1 次的合并后，优先队列中只剩下一棵树，即所要求的树T。

### 哈希表

### [HashTable.cpp](DataStructure/HashTable.cpp)

#### 构造方法

- 直接定址法
- 除留余数法
- 数字分析法
- 折叠法
- 平方取中法

#### 冲突处理方法

- 链地址法：key 相同的用单链表链接

- 开放定址法

  - 线性探测法：key 相同 -> 放到 key 的下一个位置，`Hi = (H(key) + i) % m`

  - 二次探测法：key 相同 -> 放到 `Di = 1^2, -1^2, ..., ±（k)^2,(k<=m/2）`

  - 随机探测法：`H = (H(key) + 伪随机数) % m`

    线性探测的哈希表数据结构和图片：

  typedef char KeyType;

  typedef struct {
  	KeyType key;
  }RcdType;

  typedef struct {
  	RcdType *rcd;
  	int size;
  	int count;
  	bool *tag;
  }HashTable;

### epoll怎么实现的 

Linux epoll 机制是通过红黑树和双向链表实现的。首先通过epoll_create()系统调用在内核中创建一个eventpoll 类型的句柄，其中包括红黑树根节点和双向链表头节点。然后通过epoll_ctl()系统调用，向epoll 对象的红黑树结构中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1 表示失败。最后通过epoll_wait()系统调用判断双向链表是否为空，如果为空则阻塞。当文件描述符状态改变，fd 上的回调函数被调用，该函数将fd 加入到双向链表中，此时epoll_wait 函数被唤醒，返回就绪好的事件。

### hash表的实现，包括STL中的哈希桶长度常数。

hash 表的实现主要包括构造哈希和处理哈希冲突两个方面：
对于构造哈希来说，主要包括直接地址法、平方取中法、除留余数法等。
对于处理哈希冲突来说，最常用的处理冲突的方法有开放定址法、再哈希法、链地址法、建立公共溢出区等方法。SGL 版本使用链地址法，使用一个链表保持相同散列值的元素。
虽然链地址法并不要求哈希桶长度必须为质数，但SGI STL 仍然以质数来设计哈希桶长度，并且将28 个质数（逐渐呈现大约两倍的关系）计算好，以备随时访问，同时提供一个函数，用来查询在这28 个质数之中，“最接近某数并大于某数”的质数。 

### **hash表如何rehash，**以及怎么处理其中保存的资源 

C++的hash 表中有一个负载因子loadFactor，当loadFactor<=1 时，hash 表查找的期望复杂度为O(1). 因此，每次往hash 表中添加元素时，我们必须保证是在loadFactor <1 的情况下，才能够添加。
因此，当Hash 表中loadFactor==1 时，Hash 就需要进行rehash。rehash 过程中，会模仿C++的vector 扩容方式，Hash 表中每次发现loadFactor ==1 时，就开辟一个原来桶数组的两倍空间，称为新桶数组，然后把原来的桶数组中元素全部重新哈希到新的桶数组中。

### 解决h**ash**冲突的方法 （整理题5）

当哈希表关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，这样的现象称为哈希冲突。目前常用的解决哈希冲突的方法如下：
开放定址法: 当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。
再哈希法：当发生哈希冲突时使用另一个哈希函数计算地址值，直到冲突不再发生。这种方法不易产生聚集，但是增加计算时间，同时需要准备许多哈希函数。
链地址法：将所有哈希值相同的Key 通过链表存储。key 按顺序插入到链表中建立公共溢出区：采用一个溢出表存储产生冲突的关键字。如果公共溢出区还产生冲突，再采用处理冲突方法处理。

### 加密方法都有哪些 

1、单向加密
单向加密又称为不可逆加密算法，其密钥是由加密散列函数生成的。单向散列函数一般用于产生消息摘要，密钥加密等，常见的有：
MD5（Message Digest Algorithm 5）：是RSA 数据安全公司开发的一种单向散列算法，非可逆，相同的明文产生相同的密文；
SHA（Secure Hash Algorithm）：可以对任意长度的数据运算生成一个160 位的数值。其变种由SHA192，SHA256，SHA384 等；
CRC-32，主要用于提供校验功能；
算法特征：
输入一样，输出必然相同；
雪崩效应，输入的微小改变，将会引起结果的巨大变化；

定长输出，无论原始数据多大，结果大小都是相同的；
不可逆，无法根据特征码还原原来的数据；
2、对称加密
采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。
特点：
1、加密方和解密方使用同一个密钥；
2、加密解密的速度比较快，适合数据比较长时的使用；
3、密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦；
优点：对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。
缺点：对称加密算法的缺点是在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。

3、非对称加密
非对称密钥加密也称为公钥加密，由一对公钥和私钥组成。公钥是从私钥提取出来的。可以用公钥加密，再用私钥解密，这种情形一般用于公钥加密，当然也可以用私钥加密，用公钥解密。常用于数字签名，因此非对称加密的主要功能就是加密和数字签名。
特征：
1）秘钥对，公钥(public key)和私钥(secret key)
2）主要功能：加密和签名
发送方用对方的公钥加密，可以保证数据的机密性（公钥加密）。
发送方用自己的私钥加密，可以实现身份验证（数字签名）。
3）公钥加密算法很少用来加密数据，速度太慢，通常用来实现身份验证。
常用的非对称加密算法
RSA：由RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也
是可变的；既可以实现加密，又可以实现签名。
DSA（Digital Signature Algorithm）：数字签名算法，是一种标准的DSS（数字签名标准）。

ECC（Elliptic Curves Cryptography）：椭圆曲线密码编码。

### 什么是LRU缓存 

 LRU(最近最少使用)算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高
实现：使用一个链表保存缓存数据，将新数据插入到头部，每当缓存命中时，则将命中的数据移动到链表头部，当链表满的时候，将链表尾部的数据丢弃。

## 排序

### 第k大的数的方法以及各自的复杂度**是怎样的，另外追问一下，**当有相同元素时，还可以使用什么不同的方法求第k大的元素

首先使用快速排序算法将数组按照从大到小排序，然后取第k 个，其时间复杂度最快为O(nlogn)
使用堆排序，建立最大堆，然后调整堆，知道获得第k 个元素，其时间复杂度为O(n+klogn)
首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1 个数则为第k 大的数
利用快排思想，从数组中随机选择一个数i，然后将数组分成两部分Dl,Dr，Dl 的元素都小于i,Dr 的元素都大于i。然后统计Dr 元素个数，如果Dr 元素个数等于k-1,那么第k 大的数即为k，如果Dr 元素个数小于k,那么继续求Dl 中第k-Dr 大的元素；如果Dr 元素个数大于k,那么继续求Dr 中第k 大的元素。

当有相同元素的时候，
首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1 个数则为第k 大的数，平均情况下时间复杂度为O(n)

### 各种排序算法的时间空间复杂度，特性

插入图片

### 海量数据求Top K 问题

1.直接全部排序（只适用于内存够的情况）
当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前K 个。
这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出top K个数据，所以该方法并不十分高效，不建议使用。
2.快速排序的变形（只使用于内存够的情况）
这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前K 个最大的就行。

这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index 刚好等于K，那么这个划分元以及它左边的数，刚好就是前K 个最大的元素；如果index > K，那么前K 大的数据在index 的左边，那么就继续递归的从index-1 个数中进行一趟排序；如果index< K，那么再从划分元的右边继续进行排序，直到找到序号index 刚好等于K 为止。再将前K 个数进行排序后，返回Top K 个元素。这种方法就避免了对除了Top K 个元素以外的数据进行排序所带来的不必要的开销。
3.最小堆法
这是一种局部淘汰法。先读取前K 个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K 个数。
4.分治法
将全部数据分成N 份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的K 个数。此时剩下N*K 个数据，如果内存不能容纳N*K 个数据，则再继续分治处理，分成M份，找出每份数据中最大的K 个数，如果M*K 个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。

5.Hash 法
如果这些数据中有很多重复的数据，可以先通过hash 法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。

### 快排的时间复杂度最差是多少？什么时候时间最差 ，稳定排序哪几种？

 1、快排算法
根据哨兵元素，用两个指针指向待排序数组的首尾，首指针从前往后移动找到比哨兵元素大的，尾指针从后往前移动找到比哨兵元素小的，交换两个元素，直到两个指针相遇，这是一趟排序，经常这趟排序后，比哨兵元素大的在右边，小的在左边。经过多趟排序后，整个数组有序。

稳定性：不稳定
平均时间复杂度：O(nlogn)
2、稳定排序
假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。

快排算法是不稳定的排序算法。例如：
待排序数组:int a[] ={1, 2, 2, 3, 4, 5, 6};
若选择a[2]（即数组中的第二个2）为枢轴，而把大于等于比较子的数均放置在大数数组中，则a[1]（即数组中的第一个2）会到pivot 的右边， 那么数组中的两个2 非原序。若选择a[1]为比较子，而把小于等于比较子的数均放置在小数数组中，则数组中的两个2顺序也非原序。

3、快排最差情况推倒
在快速排序的早期版本中呢，最左面或者是最右面的那个元素被选为枢轴，那最坏的情况就会在下面的情况下发生啦：
1）数组已经是正序排过序的。（每次最右边的那个元素被选为枢轴）
2）数组已经是倒序排过序的。（每次最左边的那个元素被选为枢轴）
3）所有的元素都相同（1、2 的特殊情况）
因为这些案例在用例中十分常见，所以这个问题可以通过要么选择一个随机的枢轴，或者选择一个分区中间的下标作为枢轴，或者（特别是对于相比更长的分区）选择分区的第一个、中间、最后一个元素的中值作为枢轴。有了这些修改，那快排的最差的情况就不那么容易出现了，但是如果输入的数组最大（或者最小元素）被选为枢轴，那最坏的情况就又来了。快速排序，在最坏情况退化为冒泡排序，需要比较O(n2)次（n(n - 1)/2 次）。

稳定排序有：

基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序

## 算法

### 排序查找

| 排序算法                              | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 数据对象稳定性       |
| ------------------------------------- | -------------- | -------------- | ---------- | -------------------- |
| [冒泡排序](Algorithm/BubbleSort.h)    | O(n2)          | O(n2)          | O(1)       | 稳定                 |
| [选择排序](Algorithm/SelectionSort.h) | O(n2)          | O(n2)          | O(1)       | 数组不稳定、链表稳定 |
| [插入排序](Algorithm/InsertSort.h)    | O(n2)          | O(n2)          | O(1)       | 稳定                 |
| [快速排序](Algorithm/QuickSort.h)     | O(n*log2n)     | O(n2)          | O(log2n)   | 不稳定               |
| [堆排序](Algorithm/HeapSort.cpp)      | O(n*log2n)     | O(n*log2n)     | O(1)       | 不稳定               |
| [归并排序](Algorithm/MergeSort.h)     | O(n*log2n)     | O(n*log2n)     | O(n)       | 稳定                 |
| [希尔排序](Algorithm/ShellSort.h)     | O(n*log2n)     | O(n2)          | O(1)       | 不稳定               |
| [计数排序](Algorithm/CountSort.cpp)   | O(n+m)         | O(n+m)         | O(n+m)     | 稳定                 |
| [桶排序](Algorithm/BucketSort.cpp)    | O(n)           | O(n)           | O(m)       | 稳定                 |
| [基数排序](Algorithm/RadixSort.h)     | O(k*n)         | O(n2)          |            | 稳定                 |

| 查找算法                                              | 平均时间复杂度   | 空间复杂度 | 查找条件   |
| ----------------------------------------------------- | ---------------- | ---------- | ---------- |
| [顺序查找](Algorithm/SequentialSearch.h)              | O(n)             | O(1)       | 无序或有序 |
| [二分查找（折半查找）](Algorithm/BinarySearch.h)      | O(log2n)         | O(1)       | 有序       |
| [插值查找](Algorithm/InsertionSearch.h)               | O(log2(log2n))   | O(1)       | 有序       |
| [斐波那契查找](Algorithm/FibonacciSearch.cpp)         | O(log2n)         | O(1)       | 有序       |
| [哈希查找](DataStructure/HashTable.cpp)               | O(1)             | O(n)       | 无序或有序 |
| [二叉查找树（二叉搜索树查找）](Algorithm/BSTSearch.h) | O(log2n)         |            |            |
| [红黑树](DataStructure/RedBlackTree.cpp)              | O(log2n)         |            |            |
| 2-3树                                                 | O(log2n - log3n) |            |            |
| B树/B+树                                              | O(log2n)         |            |            |

| 图搜索算法                                                   | 数据结构          | 遍历时间复杂度           | 空间复杂度               |
| ------------------------------------------------------------ | ----------------- | ------------------------ | ------------------------ |
| [BFS广度优先搜索](https://zh.wikipedia.org/wiki/广度优先搜索) | 邻接矩阵 邻接链表 | O(\|v\|2) O(\|v\|+\|E\|) | O(\|v\|2) O(\|v\|+\|E\|) |
| [DFS深度优先搜索](https://zh.wikipedia.org/wiki/深度优先搜索) | 邻接矩阵 邻接链表 | O(\|v\|2) O(\|v\|+\|E\|) | O(\|v\|2) O(\|v\|+\|E\|) |



### 剑指 Offer

- [Github . gatieme/CodingInterviews](https://github.com/gatieme/CodingInterviews)

### Leetcode Problems

- [Github . haoel/leetcode](https://github.com/haoel/leetcode)
- [Github . pezy/LeetCode](https://github.com/pezy/LeetCode)
- https://github.com/azl397985856/leetcode

## 数据结构底层实现

#### 顺序栈（Sequence Stack）

[SqStack.cpp](DataStructure/SqStack.cpp)

同上列出

### 手写代码：两个栈实现一个队列

class Solution
{
public:
void push(int node) {
stack1.push(node);
}
int pop() {
if(stack2.size()!=0){
int tmp = stack2.top();
stack2.pop();
return tmp;
}

else{
while(stack1.size()!=0){
int tmp = stack1.top();
stack1.pop();
stack2.push(tmp);
}
return pop();
}
}

private:
stack<int> stack1;
stack<int> stack2;
}；

**6****、动态规划** 

**1****、请你手写代码：**最长公共连续子序列 

**2****、手写代码：**求一个字符串最长回文子串 

**3****、手写代码：**查找最长回文子串 

 

**7****、链表** 

**1.**请你手写代码，如何**合并两个有序链表** 

**2****、手写代码：反转链表** 

**3****、**判断一个链表是否为回文链表**，**说出你的思路并手写代码 

**4****、请你**手写链表反转 

**5****、**什么是单向链表，如何判断两个单向链表是否相交 