### 红黑树和AVL树以及BST树的定义，特点，以及二者区别 

平衡二叉树（AVL 树）：
平衡二叉树又称为AVL 树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右
子树高度之差的绝对值不超过1。一句话表述为：以树中所有结点为根的树的左右子树高度之差
的绝对值不超过1。将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平
衡二叉树上的所有结点的平衡因子只可能是-1、0 和1。只要二叉树上有一个结点的平衡因子的
绝对值大于1，则该二叉树就是不平衡的。
红黑树：
红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非
红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一
条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL 树来
说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。

性质：
1. 每个节点非红即黑
2. 根节点是黑的;
3. 每个叶节点（叶节点即树尾端NULL 指针或NULL 节点）都是黑的;
4. 如果一个节点是红色的，则它的子节点必须是黑色的。
5. 对于任意节点而言，其到叶子点树NULL 指针的每条路径都包含相同数目的黑节点;
    区别：
    AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑
    树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。

### **哈夫曼编码** 

哈夫曼编码是哈夫曼树的一种应用，广泛用于数据文件压缩。哈夫曼编码算法用字符在文件
中出现的频率来建立使用0，1 表示个字符的最优表示方式，其具体算法如下：
(1)哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树T。
(2)算法以|C|个叶结点开始，执行|C|－1 次的“合并”运算后产生最终所要求的树T。
(3)假设编码字符集中每一字符c 的频率是f(c)。以f 为键值的优先队列Q 用在贪心选择时
有效地确定算法当前要合并的2 棵具有最小频率的树。一旦2 棵具有最小频率的树合并后，产生
一棵新的树，其频率为合并的2 棵树的频率之和，并将新树插入优先队列Q。经过n－1 次的合
并后，优先队列中只剩下一棵树，即所要求的树T。

### map底层为什么用红黑树实现 

红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非
红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一
条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL 树来
说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。
性质：
1. 每个节点非红即黑

2. 根节点是黑的;

3. 每个叶节点（叶节点即树尾端NULL 指针或NULL 节点）都是黑的;

4. 如果一个节点是红色的，则它的子节点必须是黑色的。

5. 对于任意节点而言，其到叶子点树NULL 指针的每条路径都包含相同数目的黑节点;
    2、平衡二叉树（AVL 树）：
    红黑树是在AVL 树的基础上提出来的。
    平衡二叉树又称为AVL 树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右
    子树高度之差的绝对值不超过1。
    AVL 树中所有结点为根的树的左右子树高度之差的绝对值不超过1。
    将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的
    所有结点的平衡因子只可能是-1、0 和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，
    则该二叉树就是不平衡的。

  3、红黑树较AVL 树的优点：
  AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑
  树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。
  所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL 里面很多结构包
  括map 底层实现都是使用的红黑树。

### 介绍一下**B+**树 

B+是一种多路搜索树，主要为磁盘或其他直接存取辅助设备而设计的一种平衡查找树，在
B+树中，每个节点的可以有多个孩子，并且按照关键字大小有序排列。所有记录节点都是按照键
值的大小顺序存放在同一层的叶节点中。相比B 树，其具有以下几个特点：
每个节点上的指针上限为2d 而不是2d+1（d 为节点的出度）

### map和u**nordered_map**的**底层实现** ，优点和缺点 

map 底层是基于红黑树实现的，因此map 内部元素排列是有序的。而unordered_map 底层则
是基于哈希表实现的，因此其元素的排列顺序是杂乱无序的。

对于map，其底层是基于红黑树实现的，优点如下：
1)有序性，这是map 结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作
2)map 的查找、删除、增加等一系列操作时间复杂度稳定，都为logn
缺点如下：
1）查找、删除、增加等操作平均时间复杂度较慢，与n 相关
对于unordered_map 来说，其底层是一个哈希表，优点如下：
查找、删除、添加的速度快，时间复杂度为常数级O(c)
缺点如下：
因为unordered_map 内部基于哈希表，以（key,value）对的形式存储，因此空间占用率高
Unordered_map 的查找、删除、添加的时间复杂度不稳定，平均为O(c)，取决于哈希函数。
极端情况下可能为O(n)

### epoll怎么实现的 

Linux epoll 机制是通过红黑树和双向链表实现的。首先通过epoll_create()系统调用在
内核中创建一个eventpoll 类型的句柄，其中包括红黑树根节点和双向链表头节点。然后通过
epoll_ctl()系统调用，向epoll 对象的红黑树结构中添加、删除、修改感兴趣的事件，返回0

标识成功，返回-1 表示失败。最后通过epoll_wait()系统调用判断双向链表是否为空，如果为
空则阻塞。当文件描述符状态改变，fd 上的回调函数被调用，该函数将fd 加入到双向链表中，
此时epoll_wait 函数被唤醒，返回就绪好的事件。

### 红黑树的性质还有左右旋转 （10题）

1）平衡二叉树（AVL 树）：
红黑树是在AVL 树的基础上提出来的。
平衡二叉树又称为AVL 树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右
子树高度之差的绝对值不超过1。
AVL 树中所有结点为根的树的左右子树高度之差的绝对值不超过1。
将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的
所有结点的平衡因子只可能是-1、0 和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，
则该二叉树就是不平衡的。
2）红黑树：
红黑树是在AVL 树的基础上发展而来的。红黑树是一种二叉查找树，但在每个节点增加一个
存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个
节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种
弱平衡二叉树，相对于要求严格的AVL 树来说，它的旋转次数少，所以对于搜索，插入，删除操
作较多的情况下，通常使用红黑树。
性质：

1. 每个节点非红即黑

2. 根节点是黑的;

3. 每个叶节点（叶节点即树尾端NULL 指针或NULL 节点）都是黑的;

4. 如果一个节点是红色的，则它的子节点必须是黑色的。

5. 对于任意节点而言，其到叶子点树NULL 指针的每条路径都包含相同数目的黑节点;
    从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。它可以在O(log n)时间内
    做查找，插入和删除，这里的n 是树中元素的数目。恢复红黑属性需要少量(O(log n))的颜色
    变更(这在实践中是非常快速的)并且不超过三次树旋转(对于插入是两次)。这允许插入和删除保
    持为O(log n) 次，

  

### 堆与栈的概念，区别和溢出

堆和栈的区别：
堆是由低地址向高地址扩展；栈是由高地址向低地址扩展
堆中的内存需要手动申请和手动释放；栈中内存是由OS 自动申请和自动释放，存放着参数、
局部变量等内存
堆中频繁调用malloc 和free,会产生内存碎片，降低程序效率；而栈由于其先进后出的特
性，不会产生内存碎片
堆的分配效率较低，而栈的分配效率较高
栈的效率高的原因：
栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储
栈的地址，压栈和入栈有专门的指令执行；而堆是由C/C++函数库提供的，机制复杂，需要一些
列分配内存、合并内存和释放内存的算法，因此效率较低。



1）申请方式：
栈由系统自动分配和管理，堆由程序员手动分配和管理。
2）效率：
栈由系统分配，速度快，不会有内存碎片。
堆由程序员分配，速度较慢，可能由于操作不当产生内存碎片。
3）扩展方向
栈从高地址向低地址进行扩展，堆由低地址向高地址进行扩展。
4）程序局部变量是使用的栈空间，new/malloc 动态申请的内存是堆空间，函数调用时会进
行形参和返回值的压栈出栈，也是用的栈空间。



栈溢出概念：
栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因
而导致栈中与其相邻的变量的值被改变。
栈溢出的原因：
1. 局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈
    中的，因此这个很好理解。解决这类问题的办法有两个，一是增大栈空间,二是改用动态分配，
    使用堆（heap）而不是栈（stack）。

2. 递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致
    堆栈溢出。

3. 指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。
    栈溢出例子：
    #include <stdio.h>
    #include <string.h>
    int main(int argc, char* argv[]) {
    char buf[256];
    strcpy(buf,argv[1]);

  printf("Input:%s\n",buf);
  return 0;
  }
  上述代码中的strcpy(buf,argv[1]);这一行发生了缓冲区溢出错误，因为源缓冲区内容是
  用户输入的。







### 手写代码：两个栈实现一个队列

class Solution
{
public:
void push(int node) {
stack1.push(node);
}
int pop() {
if(stack2.size()!=0){
int tmp = stack2.top();
stack2.pop();
return tmp;
}

else{
while(stack1.size()!=0){
int tmp = stack1.top();
stack1.pop();
stack2.push(tmp);
}
return pop();
}
}

private:
stack<int> stack1;
stack<int> stack2;
}；



### Array&List， 数组和链表的区别 

数组的特点：
数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组
中任何元素。数组的插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都
要向后移。删除数据时，这个数据后面的数据都要往前移动。但数组的随机读取效率很高。因为
数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。如果应用需要快速访
问数据，很少或不插入和删除元素，就应该用数组。数组需要预留空间，在使用前要先申请占内
存的大小，可能会浪费内存空间。并且数组不利于扩展，数组定义的空间不够时要重新定义数组。
链表的特点：
链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上
一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，
需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构
就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用
链表数据结构了。不指定大小，扩展方便。链表大小不用定义，数据随意增删。

各自的优缺点
数组的优点：
1. 随机访问性强

2. 查找速度快

  

  数组的缺点:

  1插入和删除效率低

  2可能浪费内存

3. 内存空间要求高，必须有足够的连续内存空间。

4. 数组大小固定，不能动态拓展

  

  链表的优点:

  1插入删除速度快

  2内存利用率高，不会浪费内存

  3大小没有固定，拓展很灵活。
  链表的缺点:
  不能随机查找，必须从第一个开始遍历，查找效率低

### 第k大的数的方法以及各自的复杂度**是怎样的，另外追问一下，**当有相同元素时，还可以使用什么不同的方法求第k大的元素

首先使用快速排序算法将数组按照从大到小排序，然后取第k 个，其时间复杂度最快为
O(nlogn)
使用堆排序，建立最大堆，然后调整堆，知道获得第k 个元素，其时间复杂度为O(n+klogn)
首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫
描过程中，前面有k-1 个数则为第k 大的数
利用快排思想，从数组中随机选择一个数i，然后将数组分成两部分Dl,Dr，Dl 的元素都小
于i,Dr 的元素都大于i。然后统计Dr 元素个数，如果Dr 元素个数等于k-1,那么第k 大的数即
为k，如果Dr 元素个数小于k,那么继续求Dl 中第k-Dr 大的元素；如果Dr 元素个数大于k,那
么继续求Dr 中第k 大的元素。

当有相同元素的时候，
首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫
描过程中，前面有k-1 个数则为第k 大的数，平均情况下时间复杂度为O(n)

### 各种排序算法的时间空间复杂度，特性

插入图片

### 海量数据求Top K 问题

1.直接全部排序（只适用于内存够的情况）
当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数
据全部排序，然后取排序后的数据中的前K 个。
这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方
法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出top K
个数据，所以该方法并不十分高效，不建议使用。
2.快速排序的变形（只使用于内存够的情况）
这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只
需要找出前K 个最大的就行。

这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，
比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index 刚好
等于K，那么这个划分元以及它左边的数，刚好就是前K 个最大的元素；如果index > K，那么
前K 大的数据在index 的左边，那么就继续递归的从index-1 个数中进行一趟排序；如果index
< K，那么再从划分元的右边继续进行排序，直到找到序号index 刚好等于K 为止。再将前K 个
数进行排序后，返回Top K 个元素。这种方法就避免了对除了Top K 个元素以外的数据进行排序
所带来的不必要的开销。
3.最小堆法
这是一种局部淘汰法。先读取前K 个数，建立一个最小堆。然后将剩余的所有数字依次与最
小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并
将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K 个数。
4.分治法
将全部数据分成N 份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大
的K 个数。此时剩下N*K 个数据，如果内存不能容纳N*K 个数据，则再继续分治处理，分成M
份，找出每份数据中最大的K 个数，如果M*K 个数仍然不能读到内存中，则继续分治处理。直到
剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。

5.Hash 法
如果这些数据中有很多重复的数据，可以先通过hash 法，把重复的数去掉。这样如果重复
率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则
可以直接排序；否则可以使用分治法或者最小堆法来处理数据。

### 快排的时间复杂度最差是多少？什么时候时间最差 ，稳定排序哪几种？

 1、快排算法
根据哨兵元素，用两个指针指向待排序数组的首尾，首指针从前往后移动找到比哨兵元素
大的，尾指针从后往前移动找到比哨兵元素小的，交换两个元素，直到两个指针相遇，这是一趟
排序，经常这趟排序后，比哨兵元素大的在右边，小的在左边。经过多趟排序后，整个数组有序。
稳定性：不稳定
平均时间复杂度：O(nlogn)
2、稳定排序
假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录
的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，
r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。
快排算法是不稳定的排序算法。例如：
待排序数组:int a[] ={1, 2, 2, 3, 4, 5, 6};
若选择a[2]（即数组中的第二个2）为枢轴，而把大于等于比较子的数均放置在大数数组
中，则a[1]（即数组中的第一个2）会到pivot 的右边， 那么数组中的两个2 非原序。
若选择a[1]为比较子，而把小于等于比较子的数均放置在小数数组中，则数组中的两个2
顺序也非原序。

3、快排最差情况推倒
在快速排序的早期版本中呢，最左面或者是最右面的那个元素被选为枢轴，那最坏的情况
就会在下面的情况下发生啦：
1）数组已经是正序排过序的。（每次最右边的那个元素被选为枢轴）
2）数组已经是倒序排过序的。（每次最左边的那个元素被选为枢轴）
3）所有的元素都相同（1、2 的特殊情况）
因为这些案例在用例中十分常见，所以这个问题可以通过要么选择一个随机的枢轴，或者
选择一个分区中间的下标作为枢轴，或者（特别是对于相比更长的分区）选择分区的第一个、中
间、最后一个元素的中值作为枢轴。有了这些修改，那快排的最差的情况就不那么容易出现了，
但是如果输入的数组最大（或者最小元素）被选为枢轴，那最坏的情况就又来了。
快速排序，在最坏情况退化为冒泡排序，需要比较O(n2)次（n(n - 1)/2 次）。

稳定排序有：

基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序





## **5****、哈希** 

### **1****、请你来说一说**hash表的实现，包括STL中的哈希桶长度常数。

hash 表的实现主要包括构造哈希和处理哈希冲突两个方面：
对于构造哈希来说，主要包括直接地址法、平方取中法、除留余数
法等。
对于处理哈希冲突来说，最常用的处理冲突的方法有开放定址法、再哈希法、链地址法、建
立公共溢出区等方法。SGL 版本使用链地址法，使用一个链表保持相同散列值的元素。
虽然链地址法并不要求哈希桶长度必须为质数，但SGI STL 仍然以质数来设计哈希桶长度，
并且将28 个质数（逐渐呈现大约两倍的关系）计算好，以备随时访问，同时提供一个函数，用
来查询在这28 个质数之中，“最接近某数并大于某数”的质数。 

### **2**、**请你回答一下**hash表如何rehash，**以及**怎么处理其中保存的资源 

C++的hash 表中有一个负载因子loadFactor，当loadFactor<=1 时，hash 表查找的期望复
杂度为O(1). 因此，每次往hash 表中添加元素时，我们必须保证是在loadFactor <1 的情况
下，才能够添加。
因此，当Hash 表中loadFactor==1 时，Hash 就需要进行rehash。rehash 过程中，会模仿
C++的vector 扩容方式，Hash 表中每次发现loadFactor ==1 时，就开辟一个原来桶数组的两倍
空间，称为新桶数组，然后把原来的桶数组中元素全部重新哈希到新的桶数组中。

### 解决h**ash**冲突的方法 （整理题5）

当哈希表关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，这样
的现象称为哈希冲突。目前常用的解决哈希冲突的方法如下：
开放定址法: 当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找
到空位置为止。
再哈希法：当发生哈希冲突时使用另一个哈希函数计算地址值，直到冲突不再发生。这种方
法不易产生聚集，但是增加计算时间，同时需要准备许多哈希函数。
链地址法：将所有哈希值相同的Key 通过链表存储。key 按顺序插入到链表中
建立公共溢出区：采用一个溢出表存储产生冲突的关键字。如果公共溢出区还产生冲突，再
采用处理冲突方法处理。

 

 

### 加密方法都有哪些 

1、单向加密
单向加密又称为不可逆加密算法，其密钥是由加密散列函数生成的。单向散列函数一般用
于产生消息摘要，密钥加密等，常见的有：
MD5（Message Digest Algorithm 5）：是RSA 数据安全公司开发的一种单向散列算法，非
可逆，相同的明文产生相同的密文；
SHA（Secure Hash Algorithm）：可以对任意长度的数据运算生成一个160 位的数值。其变
种由SHA192，SHA256，SHA384 等；
CRC-32，主要用于提供校验功能；
算法特征：
输入一样，输出必然相同；
雪崩效应，输入的微小改变，将会引起结果的巨大变化；

定长输出，无论原始数据多大，结果大小都是相同的；
不可逆，无法根据特征码还原原来的数据；
2、对称加密
采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方
法称为对称加密，也称为单密钥加密。
特点：
1、加密方和解密方使用同一个密钥；
2、加密解密的速度比较快，适合数据比较长时的使用；
3、密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦；
优点：对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。
缺点：对称加密算法的缺点是在数据传送前，发送方和接收方必须商定好秘钥，然后使双
方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户
每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的
钥匙数量巨大，密钥管理成为双方的负担。

3、非对称加密
非对称密钥加密也称为公钥加密，由一对公钥和私钥组成。公钥是从私钥提取出来的。可
以用公钥加密，再用私钥解密，这种情形一般用于公钥加密，当然也可以用私钥加密，用公钥解
密。常用于数字签名，因此非对称加密的主要功能就是加密和数字签名。
特征：
1）秘钥对，公钥(public key)和私钥(secret key)
2）主要功能：加密和签名
发送方用对方的公钥加密，可以保证数据的机密性（公钥加密）。
发送方用自己的私钥加密，可以实现身份验证（数字签名）。
3）公钥加密算法很少用来加密数据，速度太慢，通常用来实现身份验证。
常用的非对称加密算法
RSA：由RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也
是可变的；既可以实现加密，又可以实现签名。
DSA（Digital Signature Algorithm）：数字签名算法，是一种标准的DSS（数字签名标准）。

ECC（Elliptic Curves Cryptography）：椭圆曲线密码编码。

### 什么是LRU缓存 

 LRU(最近最少使用)算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数
据最近被访问过，那么将来被访问的几率也更高
实现：使用一个链表保存缓存数据，将新数据插入到头部，每当缓存命中时，则将命中的数据移
动到链表头部，当链表满的时候，将链表尾部的数据丢弃。



**6****、动态规划** 

**1****、请你手写代码：**最长公共连续子序列 

**2****、手写代码：**求一个字符串最长回文子串 

**3****、手写代码：**查找最长回文子串 

 

**7****、链表** 

**1.**请你手写代码，如何**合并两个有序链表** 

**2****、手写代码：反转链表** 

**3****、**判断一个链表是否为回文链表**，**说出你的思路并手写代码 

**4****、请你**手写链表反转 

**5****、**什么是单向链表，如何判断两个单向链表是否相交 