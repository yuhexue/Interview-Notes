### 进程与线程的概念和区别

进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；
线程是进程的子任务，是CPU 调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。

每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。

区别：
1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。
2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）
3.进程是资源分配的最小单位，线程是CPU 调度的最小单位；
4.系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU 环境的保存以及新被调度运行的进程的CPU 环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。
5.通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预
6.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。
7.进程间不会相互影响；线程一个线程挂掉将导致整个进程挂掉

8.进程适应于多核、多机分布；线程适用于多核

### 进程间的通信和同步

进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及
套接字socket。

#### 管道：

管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信

##### 普通管道PIPE：

1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端
2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）
3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

##### 命名管道FIFO：

1)FIFO 可以在无关的进程之间交换数据
2)FIFO 有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

#### 消息队列

消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。(消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；
特点：
1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。
2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。
3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息
的类型读取。

#### 信号量semaphore

信号量（semaphore）与已经介绍过的IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。
特点：
  1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
  2)信号量基于操作系统的PV 操作，程序对信号量的操作都是原子操作。
  3)每次对信号量的PV 操作不仅限于对信号量值加1 或减1，而且可以加减任意正整数。
  4)支持信号量组。

#### 信号signal

信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

#### 共享内存（Shared Memory）

它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等
特点：
  1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取
  2)因为多个进程可以同时操作，所以需要进行同步
  3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问

#### 套接字SOCKET：

socket 也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。

### 进程之间的通信方式对比

- 管道（PIPE）
  - 有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信
    - 优点：可以实现任意关系的进程间的通信
    - 缺点：
      1. 长期存于系统中，使用不当容易出错
      2. 缓冲区有限
  - 无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）
    - 优点：简单方便
    - 缺点：
      1. 局限于单向通信 
      2. 只能创建在它的进程以及其有亲缘关系的进程之间
      3. 缓冲区有限
- 信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问
  - 优点：可以同步进程
  - 缺点：信号量有限
- 信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
- 消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识
  - 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便
  - 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合
- 共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问
  - 优点：无须复制，快捷，信息量大
  - 缺点：
    1. 通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题
    2. 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信
- 套接字（Socket）：可用于不同及其间的进程通信
  - 优点：
    1. 传输数据为字节级，传输数据可自定义，数据量小效率高
    2. 传输数据时间短，性能高
    3. 适合于客户端和服务器端之间信息实时交互
    4. 可以加密,数据安全性强
  - 缺点：需对传输的数据进行解析，转化成应用级的数据。

### 线程间通信的方式

临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；

互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问

信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

信号量
信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：
P(SV):如果信号量SV 大于0，将它减一；如果SV 值为0，则挂起该线程。
V(SV)：如果有其他进程因为等待SV 而挂起，则唤醒，然后将SV+1；否则直接将SV+1。
其系统调用为：
sem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0 值。
sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0 时，其他正在调用sem_wait 等待信号量的线程将被唤醒。

互斥量
互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。
当进入临界区时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：
pthread_mutex_init:初始化互斥锁
pthread_mutex_destroy：销毁互斥锁
pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，
pthread_mutex_lock 调用将阻塞，直到该互斥锁的占有者将其解锁。
pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁。



条件变量
条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通
信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个
共享变量等于某个值时，调用signal/broadcast。此时操作共享变量时需要加锁。其主要的系
统调用如下：

pthread_cond_init:初始化条件变量
pthread_cond_destroy：销毁条件变量
pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策
略和优先级。
pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函
数中在进入wait 状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正
确访问。

### 线程之间的通信方式对比

- 锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）
  - 互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。
  - 读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。
  - 自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。
  - 条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
- 信号量机制(Semaphore)
  - 无名线程信号量
  - 命名线程信号量
- 信号机制(Signal)：类似进程间的信号处理
- 屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。

线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制  

> 进程之间的通信方式以及优缺点来源于：[进程线程面试题总结](http://blog.csdn.net/wujiafei_njgcxy/article/details/77098977)

### 进程之间私有和共享的资源

- 私有：地址空间、堆、全局变量、栈、寄存器
- 共享：代码段，公共数据，进程目录，进程 ID

### 线程之间私有和共享的资源

- 私有：线程栈，寄存器，程序寄存器
- 共享：堆，地址空间，全局变量，静态变量

### 多进程与多线程间的对比、优劣与选择

进程是资源分配的最小单位，而线程时CPU 调度的最小单位。多线程之间共享同一个进程的
地址空间，线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存少，适
用于多核分布式系统，但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程
也终止，程序可靠性弱。而多进程间拥有各自独立的运行地址空间，进程间不会相互影响，程序
可靠性强，但是进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步
简单，适用于多核、多机分布。



多进程模型的优势是CPU
多线程模型主要优势为线程间切换代价较小，因此适用于I/O 密集型的工作场景，因此I/O
密集型的工作场景经常会由于I/O 阻塞导致频繁的切换线程。同时，多线程模型也适用于单机多
核分布式场景。
多进程模型，适用于CPU 密集型。同时，多进程模型也适用于多机分布式场景中，易于多机
扩展。

| 对比维度       | 多进程                                                       | 多线程                                                       | 总结     |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 数据共享、同步 | 数据共享复杂，需要用 IPC；数据是分开的，同步简单             | 因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂 | 各有优势 |
| 内存、CPU      | 占用内存多，切换复杂，CPU 利用率低                           | 占用内存少，切换简单，CPU 利用率高                           | 线程占优 |
| 创建销毁、切换 | 创建销毁、切换复杂，速度慢                                   | 创建销毁、切换简单，速度很快                                 | 线程占优 |
| 编程、调试     | 编程简单，调试简单                                           | 编程复杂，调试复杂                                           | 进程占优 |
| 可靠性         | 进程间不会互相影响                                           | 一个线程挂掉将导致整个进程挂掉                               | 进程占优 |
| 分布式         | 适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单 | 适应于多核分布式                                             | 进程占优 |

| 优劣 | 多进程                                   | 多线程                                   |
| ---- | ---------------------------------------- | ---------------------------------------- |
| 优点 | 编程、调试简单，可靠性较高               | 创建、销毁、切换速度快，内存、资源占用小 |
| 缺点 | 创建、销毁、切换速度慢，内存、资源占用大 | 编程、调试复杂，可靠性较差               |

- 需要频繁创建销毁的优先用线程
- 需要进行大量计算的优先使用线程
- 强相关的处理用线程，弱相关的处理用进程
- 可能要扩展到多机分布的用进程，多核分布的用线程
- 都满足需求的情况下，用你最熟悉、最拿手的方式

> 多进程与多线程间的对比、优劣与选择来自：[多线程还是多进程的选择及区别](https://blog.csdn.net/lishenglong666/article/details/8557215)

### 进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞（28题）

### 有了进程为什么还需要线程

线程产生的原因：
进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：
进程在同一时间只能干一件事
进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。

因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。和进程相比，线程的优势如下：从资源上来讲，线程是一种非常"节俭"的多任务操作方式。在linux 系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种"昂贵"的多任务工作方式。
从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30 倍左右。（从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。
除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：
1、使多CPU 系统更加有效。操作系统会保证当线程数不大于CPU 数目时，不同的线程运行于不同的CPU 上。
2、改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。

### 进程死锁发生的条件以及如何解决死锁 

死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下：
互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；
请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源
不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放
环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链

解决死锁的方法即破坏上述四个条件之一，主要方法如下：
资源一次性分配，从而剥夺请求和保持条件
可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件
资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件



#### 预防

- 打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。
- 打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。
- 打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。
- 打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。
- 有序资源分配法
- 银行家算法





死锁必要条件及避免算法

1、资源不能共享，只能由一个进程使用。
2、请求与保持（Hold andwait）：已经得到资源的进程可以再次申请新的资源。
3、不可剥夺（Nopre-emption）：已经分配的资源不能从相应的进程中被强制地剥夺。
4、循环等待：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源

处理死锁的策略：1.忽略该问题。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧。跟掩耳盗铃有点像。2.检测死锁并且恢复。3.仔细地对资源进行动态分配，以避免死锁。4.通过破除死锁四个必要条件之一，来防止死锁产生。）

### 线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的 

线程在切换的过程中需要保存当前线程Id、线程状态、堆栈、寄存器状态等信息。其中寄
存器主要包括SP PC EAX 等寄存器，其主要功能如下：
SP:堆栈指针，指向当前栈的栈顶地址

PC:程序计数器，存储下一条将要执行的指令
EAX:累加寄存器，用于加法乘法的缺省寄存器

### 游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？

游戏服务器应该为每个用户开辟一个进程。因为同一进程间的线程会相互影响，一个线程死掉会影响其他线程，从而导致进程崩溃。因此为了保证不同用户之间不会相互影响，应该为每个用户开辟一个进程

### 就绪状态的进程在等待什么

被调度使用cpu 的运行权

### 两个进程访问临界区资源，会不会出现都获得自旋锁的情况

单核cpu，并且开了抢占可以造成这种情况。

### 孤儿进程和僵尸进程，危害和解决

1）正常进程
正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。
unix 提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息，直到父进程通过wait / waitpid 来取时才释放。保存信息包括：
1 进程号the process ID
2 退出状态the termination status of the process
3 运行时间the amount of CPU time taken by the process 等

2）孤儿进程
一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init 进程(进程号为1)所收养，并由init 进程对它们完成状态收集工作。
3）僵尸进程
一个进程使用fork 创建子进程，如果子进程退出，而父进程并没有调用wait 或waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。
僵尸进程是一个进程必然会经过的过程：这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps 命令就能看到子进程的状态是“Z”。
如果父进程能及时处理，可能用ps 命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。
如果父进程在子进程结束之前退出，则子进程将由init 接管。init 将会以父进程的身份对僵尸状态的子进程进行处理。

危害：
如果进程不调用wait / waitpid 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。
外部消灭：
通过kill 发送SIGTERM 或者SIGKILL 信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init 进程接管，init 进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源
内部解决：
1、子进程退出时向父进程发送SIGCHILD 信号，父进程处理SIGCHILD 信号。在信号处理函数中调用wait 进行处理僵尸进程。
2、fork 两次，原理是将子进程成为孤儿进程，从而其的父进程变为init 进程，通过init 进程可以处理僵尸进程。





### 常用线程模型

1、Future 模型
该模型通常在使用的时候需要结合Callable 接口配合使用。Future 是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。
Callable 是类似于Runnable 的接口，其中call 方法类似于run 方法，所不同的是run 方法不能抛出受检异常没有返回值，而call 方法则可以抛出受检异常并可设置返回值。两者的方法体都是线程执行体。

2、fork&join 模型
该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。这里模拟一个摘苹果的场景：有100 棵苹果树，每棵苹果树有10 个苹果，现在要把他们摘下来。为了节约时间，规定每个线程最多只能摘10 棵苹树以便于节约时间。各个线程摘完之后汇总计算总苹果树。
3、actor 模型
actor 模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor 在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor 进行处理。在使用actor 模型的时候需要使用第三方Akka 提供的框架。
4、生产者消费者模型
生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。

比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避任务的处理响应缓慢的问题。

5、master-worker 模型

master-worker 模型类似于任务分发策略，开启一个master 线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker 子线程，然后由子线程处理任务。如需返回结果，则worker 处理结束之后把处理结果回给master。

### 实现线程池

1.设置一个生产者消费者队列，作为临界资源
2.初始化n 个线程，并让其运行起来，加锁去队列取任务运行
3.当任务队列为空的时候，所有线程阻塞
4.当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通
知阻塞中的一个线程



