### **数据库事务以及四个特性** 

事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执
行逻辑单元。事务是DBMS 中最基础的单位，事务不可分割。
事务具有4 个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性
（Isolation）、持久性（Duration），简称ACID。
1. 原子性（Atomicity）
    原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，[删删删]因此事务
    的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

2. 一致性（Consistency）
    一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一
    个事务执行之前和执行之后都必须处于一致性状态。
    拿转账来说，假设用户A 和用户B 两者的钱加起来一共是5000，那么不管A 和B 之间
    如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致
    性。

3. 隔离性（Isolation）
    隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开
    启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
    即要达到这么一种效果：对于任意两个并发的事务T1 和T2，在事务T1 看来，T2 要么
    在T1 开始之前就已经结束，要么在T1 结束之后才开始，这样每个事务都感觉不到有其他事务在
    并发地执行。

  多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。
  这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数
  据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。

  不同的隔离级别：
  Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，什么都不需要做，
  一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。
  Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。
  可以解决脏读问题。
  Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无
  论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。
  Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可
  以解决并发事务的所有问题。
  4. 持久性（Durability）

    持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便
    是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
    例如我们在使用JDBC 操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们
    程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，
    也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因
    为故障而没有执行事务的重大错误。

### **数据库的三大范式** 

第一范式：当关系模式R 的所有属性都不能再分解为更基本的数据单位时，称R 是满足第
一范式，即属性不可分
第二范式：如果关系模式R 满足第一范式，并且R 得所有非主属性都完全依赖于R 的每一个
候选关键属性，称R 满足第二范式
第三范式：设R 是一个满足第一范式条件的关系模式，X 是R 的任意属性集，如果X 非传递
依赖于R 的任意一个候选关键字，称R 满足第三范式，即非主属性不传递依赖于键码

### 数据库索引

索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中
的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于
更快地获取信息。
索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制
条件的记录ID 的辅助数据结构。



1、索引
数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列
的值进行排序的一种结构。
DB 在执行一条Sql 语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件
的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到
特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。
优点：
通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
缺点：
创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如
果要建立聚簇索引，那么需要的空间就会更大。

当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的
维护速度。
2、添加索引原则
在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因
此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速
度和增大了空间需求。
只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表
的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的
数据行的比例很大。增加索引，并不能明显加快检索速度。
定义为text、image 和bit 数据类型的列不应该增加索引。这是因为，这些列的数据量要
么相当大，要么取值很少。
当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互
相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改
性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。





### **inner join和left join** 

left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录
right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录
inner join(等值连接) 只返回两个表中联结字段相等的行



 

**2****、Mysql** 

###  mysql**的**四种隔离状态 

插入表格

### m**ysql**的M**VCC**机制 

MVCC 是一种多版本并发控制机制，是MySQL 的InnoDB 存储引擎实现隔离级别的一种具体方
式，用于实现提交读和可重复读这两种隔离级别。MVCC 是通过保存数据在某个时间点的快照来
实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号，
然后Innodb 的MVCC 使用到的快照存储在Undo 日志中，该日志通过回滚指针把一个数据行所有
快照连接起来。

### SQL优化方法有哪些 

通过建立索引对查询进行优化
对查询进行优化，应尽量避免全表扫描

### MySQL引擎和区别 

 1、MySQL 引擎
MySQL 中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都
使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不
同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。
数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并
快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。使用数据库引擎
创建用于联机事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于
查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。
MySQL 存储引擎主要有： MyIsam、InnoDB、Memory、Blackhole、CSV、Performance_Schema、
Archive、Federated、Mrg_Myisam。
但是最常用的是InnoDB 和Mylsam。

2、InnoDB
InnoDB 是一个事务型的存储引擎，有行级锁定和外键约束。
Innodb 引擎提供了对数据库ACID 事务的支持，并且实现了SQL 标准的四种隔离级别，关于
数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这类型的文章。该引擎还提供了行
级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL 后台的完
整数据库系统，MySQL 运行时Innodb 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引
擎不支持FULLTEXT 类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE
时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不
会锁定全表，所以在并发较高时，使用Innodb 引擎会提升效率。但是使用行级锁也不是绝对的，
如果在执行一个SQL 语句时MySQL 不能确定要扫描的范围，InnoDB 表同样会锁全表。
适用场景：
经常更新的表，适合处理多重并发的更新请求。
支持事务。
可以从灾难中恢复（通过bin-log 日志等）。
外键约束。只有他支持外键。
支持自动增加列属性auto_increment。

索引结构：
InnoDB 也是B+Treee 索引结构。Innodb 的索引文件本身就是数据文件，即B+Tree 的数据
域存储的就是实际的数据，这种索引就是聚集索引。这个索引的key 就是数据表的主键，因此
InnoDB 表数据文件本身就是主索引。
InnoDB 的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查
找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb 不建议使用

过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree 的每一
个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。
3、Mylsam
MyIASM 是MySQL 默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外
键，因此当INSERT 或UPDATE 数据时即写操作需要锁定整个表，效率便会低一些。MyIsam 存储
引擎独立于操作系统，也就是可以在windows 上使用，也可以比较简单的将数据转移到linux
操作系统上去。
适用场景：
不支持事务的设计，但是并不代表着有事务操作的项目不能用MyIsam 存储引擎，可以在
service 层进行根据自己的业务需求进行相应的控制。
不支持外键的表设计。
查询速度很快，如果数据库insert 和update 的操作比较多的话比较适用。
整天对表进行加锁的场景。
MyISAM 极度强调快速读取操作。
MyIASM 中存储了表的行数，于是SELECT COUNT(*) FROM TABLE 时只需要直接读取已经保存
好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那
么MyIASM 也是很好的选择。
缺点：就是不能在表损坏后主动恢复数据。

索引结构：
MyISAM 索引结构：MyISAM 索引用的B+ tree 来储存数据，MyISAM 索引的指针指向的是键值
的地址，地址存储的是数据。B+Tree 的数据域存储的内容为实际数据的地址，也就是说它的索
引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引。
3、InnoDB 和Mylsam 的区别：
1）事务：MyISAM 类型不支持事务处理等高级处理，而InnoDB 类型支持，提供事务支持已
经外部键等高级数据库功能。
2）性能：MyISAM 类型的表强调的是性能，其执行数度比InnoDB 类型更快。
3）行数保存：InnoDB 中不保存表的具体行数，也就是说，执行select count() fromtable
时，InnoDB 要扫描一遍整个表来计算有多少行，但是MyISAM 只要简单的读出保存好的行数即可。
注意的是，当count()语句包含where 条件时，两种表的操作是一样的。
4）索引存储：对于AUTO_INCREMENT 类型的字段，InnoDB 中必须包含只有该字段的索引，
但是在MyISAM 表中，可以和其他字段一起建立联合索引。MyISAM 支持全文索引（FULLTEXT）、
压缩索引，InnoDB 不支持。



MyISAM 的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能
加载更多索引，而Innodb 是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb 比
MyISAM 体积庞大不小。
InnoDB 存储引擎被完全与MySQL 服务器整合，InnoDB 存储引擎为在主内存中缓存数据和索
引而维持它自己的缓冲池。InnoDB 存储它的表＆索引在一个表空间中，表空间可以包含数个文
件（或原始磁盘分区）。这与MyISAM 表不同，比如在MyISAM 表中每个表被存在分离的文件中。
InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB 的操作系统上。
5）服务器数据备份：InnoDB 必须导出SQL 来备份，LOAD TABLE FROM MASTER 操作对InnoDB
是不起作用的，解决方法是首先把InnoDB 表改成MyISAM 表，导入数据后再改成InnoDB 表，但
是对于使用的额外的InnoDB 特性(例如外键)的表不适用。
MyISAM 应对错误编码导致的数据恢复速度快。MyISAM 的数据是以文件的形式存储，所以在
跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。
InnoDB 是拷贝数据文件、备份binlog，或者用mysqldump，在数据量达到几十G 的时候就
相对痛苦了。
6）锁的支持：MyISAM 只支持表锁。InnoDB 支持表锁、行锁行锁大幅度提高了多用户并发
操作的新能。但是InnoDB 的行锁，只是在WHERE 的主键是有效的，非主键的WHERE 都会锁全表
的。











**3****、Redis** 

 

### mongodb**和**redis**的**区别

内存管理机制上：Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定
的LRU 算法删除数据。MongoDB 数据存在内存，由linux 系统mmap 实现，当内存不够时，只
将热点数据放入内存，其他数据存在磁盘。
支持的数据结构上：Redis 支持的数据结构丰富，包括hash、set、list 等。
MongoDB 数据结构比较单一，但是支持丰富的数据表达，索引，最类似关系型数据库，支持
的查询语言非常丰富

###  Redis 和memcached 的区别

1）数据类型：redis 数据类型丰富，支持set liset 等类型；memcache 支持简单数据类型，
需要客户端自己处理复杂对象
2）持久性：redis 支持数据落地持久化存储；memcache 不支持数据持久存储。)
3）分布式存储：redis 支持master-slave 复制模式；memcache 可以使用一致性hash 做分
布式。
4）value 大小不同：memcache 是一个内存缓存，key 的长度小于250 字符，单个item 存储
要小于1M，不适合虚拟机使用

5）数据一致性不同：redis 使用的是单线程模型，保证了数据按顺序提交；memcache 需要
使用cas 保证数据一致性。CAS（Check and Set）是一个确保并发一致性的机制，属于“乐观锁”
范畴；原理很简单：拿版本号，操作，对比版本号，如果一致就操作，不一致就放弃任何操作
6）cpu 利用：redis 单线程模型只能使用一个cpu，可以开启多个redis 进程

### mysql引擎**以及其**区别 

在Mysql 数据库中，常用的引擎为Innodb 和MyIASM,其中Innodb 是一个事务型的存储引擎，
有行级锁定和外键约束，提供了对数据库ACID 事物的支持，实现了SQL 标准的四种隔离级别，
即读未提交，不可重复读，可重复读以及串行,其涉及目标就是处理大数据容量的数据库系统。
而MyIASM 引擎是Mysql 默认的引擎，不提供数据库事务的支持，也不支持行级锁和外键，因此
当写操作时需要锁定整个表，效率较低。不过其保存了表的行数，当金星select count(*)form
table 时，可直接读取已经保存的值，不需要进行全表扫描。因此当表的读操作远多于写操作，
并且不需要事务支持时，可以优先选择MyIASM

### Redis的定时机制怎么实现的 

Redis 服务器是一个事件驱动程序，服务器需要处理以下两类事件：文件事件（服务器对套
接字操作的抽象）和时间事件（服务器对定时操作的抽象）。Redis 的定时机制就是借助时间事
件实现的。
一个时间事件主要由以下三个属性组成：id：时间事件标识号；when：记录时间事件的到达
时间；timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理时
间。一个时间事件根据时间事件处理器的返回值来判断是定时事件还是周期性事件
一个时间事件主要由以下三个属性组成：id：时间事件标识号；when：记录时间事件的到达
时间；timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理时
间。一个时间事件根据时间事件处理器的返回值来判断是定时事件还是周期性事件。

### Redis是单线程的，**但是**为什么这么高效**呢**? 

虽然Redis 文件事件处理器以单线程方式运行，但是通过使用I/O 多路复用程序来监听多个
套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis 服务器中其他
同样以单线程运行的模块进行对接，这保持了Redis 内部单线程设计的简单性。

### Redis的数据类型及其底层实现

1）字符串：整数值、embstr 编码的简单动态字符串、简单动态字符串（SDS)
2）列表：压缩列表、双端链表
3）哈希：压缩列表、字典
4）集合：整数集合、字典
5）有序集合：压缩列表、跳跃表和字典









\##数据库： 谈谈你对数据库中索引的理解，索引和主键区别

聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个。

聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续。

·          

```
  聚集索引：该索引中键值的逻辑顺序决定了表中相应行的物理顺序。
  聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。
       聚集索引使用注意事项
 
   定义聚集索引键时使用的列越少越好。
   • 包含大量非重复值的列。
  .• 使用下列运算符返回一个范围值的查询：BETWEEN、>、>=、< 和 <=。
   •  被连续访问的列。
   •  回大型结果集的查询。
   • 经常被使用联接或 GROUP BY 子句的查询访问的列；一般来说，这些是外键列。对 ORDER BY 或 GROUP BY 子句中指定的列进行索引，可以使 SQL Server 不必对数据进行排序，因为这些行已经排序。这样可以提高查询性能。
  •  OLTP 类型的应用程序，这些程序要求进行非常快速的单行查找（一般通过主键）。应在主键上创建聚集索引。
  聚集索引不适用于：
 
   • 频繁更改的列 。这将导致整行移动（因为 SQL Server 必须按物理顺序保留行中的数据值）。这一点要特别注意，因为在大数据量事务处理系统中数据是易失的。
   • 宽键 。来自聚集索引的键值由所有非聚集索引作为查找键使用，因此存储在每个非聚集索引的叶条目内。
   
   非聚集索引：数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。
 
    非聚集索引中的项目按索引键值的顺序存储，而表中的信息按另一种顺序存储（这可以由聚集索引规定）。对于非聚集索引，可以为在表非聚集索引中查找数据时常用的每个列创建一个非聚集索引。有些书籍包含多个索引。例如，一本介绍园艺的书可能会包含一个植物通俗名称索引，和一个植物学名索引，因为这是读者查找信息的两种最常用的方法。
    
    一个通俗的举例，说明两者的区别
 
    其实，我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an”，而按照拼音排序汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”字就自然地排在字典的前部。如果您翻完了所有以“a”开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；同样的，如果查“张”字，那您也会将您的字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说，字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。
  　   如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查“张”字，我们可以看到在查部首之后的检字表中“张”的页码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在您看到的连续的“驰、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。
 
  第一：聚集索引的约束是唯一性，是否要求字段也是唯一的呢？
  分析：如果认为是的朋友，可能是受系统默认设置的影响，一般我们指定一个表的主键，如果这个表之前没有聚集索引，同时建立主键时候没有强制指定使用非聚集索引,SQL会默认在此字段上创建一个聚集索引，而主键都是唯一的，所以理所当然的认为创建聚集索引的字段也需要唯一。
  结论：聚集索引可以创建在任何一列你想创建的字段上，这是从理论上讲，实际情况并不能随便指定，否则在性能上会是恶梦。
  第二：为什么聚集索引可以创建在任何一列上，如果此表没有主键约束，即有可能存在重复行数据呢？
  粗一看，这还真是和聚集索引的约束相背，但实际情况真可以创建聚集索引。
  分析其原因是：如果未使用 UNIQUE 属性创建聚集索引，数据库引擎将向表自动添加一个四字节 uniqueifier 列。必要时，数据库引擎 将向行自动添加一个 uniqueifier 值，使每个键唯一。此列和列值供内部使用，用户不能查看或访问。
  第三：是不是聚集索引就一定要比非聚集索引性能优呢？
  如果想查询学分在60-90之间的学生的学分以及姓名，在学分上创建聚集索引是否是最优的呢？
  答：否。既然只输出两列，我们可以在学分以及学生姓名上创建联合非聚集索引，此时的索引就形成了覆盖索引，即索引所存储的内容就是最终输出的数据，这种索引在比以学分为聚集索引做查询性能更好。
  第四：在数据库中通过什么描述聚集索引与非聚集索引的？
  索引是通过二叉树的形式进行描述的，我们可以这样区分聚集与非聚集索引的区别：聚集索引的叶节点就是最终的数据节点，而非聚集索引的叶节仍然是索引节点，但它有一个指向最终数据的指针。
  第五：在主键是创建聚集索引的表在数据插入上为什么比主键上创建非聚集索引表速度要慢？
  有了上面第四点的认识，我们分析这个问题就有把握了，在有主键的表中插入数据行，由于有主键唯一性的约束，所以需要保证插入的数据没有重复。我们来比较下主键为聚集索引和非聚集索引的查找情况:聚集索引由于索引叶节点就是数据页，所以如果想检查主键的唯一性，需要遍历所有数据节点才行，但非聚集索引不同，由于非聚集索引上已经包含了主键值，所以查找主键唯一性，只需要遍历所有的索引页就行，这比遍历所有数据行减少了不少IO消耗。这就是为什么主键上创建非聚集索引比主键上创建聚集索引在插入数据时要快的真正原因。
```

·          

现在普通关系数据库用得数据结构是什么类型的数据结构，

```
B+树
[MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)
```

索引的优点和缺点，

```
建立索引的优点
1.大大加快数据的检索速度;
2.创建唯一性索引，保证数据库表中每一行数据的唯一性;
3.加速表和表之间的连接;
4.在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。
 
索引的缺点
1.索引需要占物理空间。
2.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。
 
唯一索引
唯一索引是不允许其中任何两行具有相同索引值的索引。
当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在 employee 表中职员的姓 (lname) 上创建了唯一索引，则任何两个员工都不能同姓。
 
主键索引
数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。
在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。
 
聚集索引
在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。
如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。 
```

关系型数据库和非关系数据库的特点，

```
简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。
 
非关系型数据库提出另一种理念，例如，以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，这 样就不会局限于固定的结构，可以减少一些时间和空间的开销。使用这种方式，用户可以根据需要去添加自己需要的字段，这样，为了获取用户的不同信息，不需要 像关系型数据库中，要对多表进行关联查询。仅需要根据id取出相应的value就可以完成查询。但非关系型数据库由于很少的约束，他也不能够提供像SQL 所提供的where这种对于字段属性值情况的查询。并且难以体现设计的完整性。他只适合存储一些较为简单的数据，对于需要进行较复杂查询的数据，SQL数 据库显的更为合适。
 
关系型数据库的最大特点就是事务的一致性：传统的关系型数据库读写操作都是事务的，具有ACID的特点，这个特性使得关系型数据库可以用于几乎所有对一致性有要求的系统中，如典型的银行系统。
 
但是，在网页应用中，尤其是SNS应用中，一致性却不是显得那么重要，用户A看到的内容和用户B看到同一用户C内容更新不一致是可以容忍的，或者 说，两个人看到同一好友的数据更新的时间差那么几秒是可以容忍的，因此，关系型数据库的最大特点在这里已经无用武之地，起码不是那么重要了。
 
相反地，关系型数据库为了维护一致性所付出的巨大代价就是其读写性能比较差，而像微博、facebook这类SNS的应用，对并发读写能力要求极 高，关系型数据库已经无法应付(在读方面，传统上为了克服关系型数据库缺陷，提高性能，都是增加一级memcache来静态化网页，而在SNS中，变化太 快，memchache已经无能为力了)，因此，必须用新的一种数据结构存储来代替关系数据库。
 
关系数据库的另一个特点就是其具有固定的表结构，因此，其扩展性极差，而在SNS中，系统的升级，功能的增加，往往意味着数据结构巨大变动，这一点关系型数据库也难以应付，需要新的结构化数据存储。
 
于是，非关系型数据库应运而生，由于不可能用一种数据结构化存储应付所有的新的需求，因此，非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。
 
必须强调的是，数据的持久存储，尤其是海量数据的持久存储，还是需要一种关系数据库这员老将。
非关系型数据库分类：
主要分为以下几类：
         
面向高性能并发读写的key-value数据库：
 
key-value数据库的主要特点即使具有极高的并发读写性能，Redis,Tokyo Cabinet,Flare就是这类的代表
 
面向海量数据访问的面向文档数据库：
 
这类数据库的特点是，可以在海量的数据中快速的查询数据，典型代表为MongoDB以及CouchDB
 
面向可扩展性的分布式数据库：
 
这类数据库想解决的问题就是传统数据库存在可扩展性上的缺陷，这类数据库可以适应数据量的增加以及数据结构的变化
```

[关系型数据库和非关系型数据库](http://my.oschina.net/u/1773689/blog/364548)

乐观锁与悲观锁的区别，

```
悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。[1]      悲观锁假定其他用户企图访问或者改变你正在访问、更改的对象的概率是很高的，因此在悲观锁的环境中，在你开始改变此对象之前就将该对象锁住，并且直到你提交了所作的更改之后才释放锁。悲观的缺陷是不论是页锁还是行锁，加锁的时间可能会很长，这样可能会长时间的限制其他用户的访问，也就是说悲观锁的并发访问性不好。
 
乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。[1] 乐观锁不能解决脏读的问题。    乐观锁则认为其他用户企图改变你正在更改的对象的概率是很小的，因此乐观锁直到你准备提交所作的更改时才将对象锁住，当你读取以及改变该对象时并不加锁。可见乐观锁加锁的时间要比悲观锁短，乐观锁可以用较大的锁粒度获得较好的并发访问性能。但是如果第二个用户恰好在第一个用户提交更改之前读取了该对象，那么当他完成了自己的更改进行提交时，数据库就会发现该对象已经变化了，这样，第二个用户不得不重新读取该对象并作出更改。这说明在乐观锁环境中，会增加并发用户读取对象的次数。
 
从数据库厂商的角度看，使用乐观的页锁是比较好的，尤其在影响很多行的批量操作中可以放比较少的锁，从而降低对资源的需求提高数据库的性能。再考虑聚集索引。在数据库中记录是按照聚集索引的物理顺序存放的。如果使用页锁，当两个用户同时访问更改位于同一数据页上的相邻两行时，其中一个用户必须等待另一个用户释放锁，这会明显地降低系统的性能。interbase和大多数关系数据库一样，采用的是乐观锁，而且读锁是共享的，写锁是排他的。可以在一个读锁上再放置读锁，但不能再放置写锁；你不能在写锁上再放置任何锁。锁是目前解决多用户并发访问的有效手段。  
 
 
 
[乐观锁与悲观锁的区别](http://www.cnblogs.com/Bob-FD/p/3352216.html)
 
```



