### C++源文件从文本到可执行文件经历的过程**？** 

对于C++源文件，从文本到可执行文件一般需要四个过程：
预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和
替换，生成预编译文件。
编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件
汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件
链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件

### include**头文件的顺序以及双引号和尖括号**的区别？ 

Include 头文件的顺序：对于include 的头文件来说，如果在文件a.h 中声明一个在文件b.h
中定义的变量，而不引用b.h。那么要在a.c 文件中引用b.h 文件，并且要先引用b.h，后引用
a.h,否则汇报变量类型未声明错误。
双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。
对于使用双引号包含的头文件，查找头文件路径的顺序为：
当前头文件目录
编译器设置的头文件路径（编译器可使用-I 显式指定搜索路径）
系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径
对于使用尖括号包含的头文件，查找头文件的路径顺序为：
编译器设置的头文件路径（编译器可使用-I 显式指定搜索路径）

系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径

### C++的内存管理和内存分配 ，内存泄露（memory leak）的判断

在C++中，虚拟内存分为代码段、数据段、BSS 段、堆区、文件映射区以及栈区六部分。
代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机
器代码。
数据段：存储程序中已初始化的全局变量和静态变量
bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0 的全
局变量和静态变量。
堆区： 调用new/malloc 函数时在堆区动态分配内存，同时需要调用delete/free 来手动释
放申请的内存。
映射区:存储动态链接库以及调用mmap 函数进行的文件映射

栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值







![4](C:\Users\yuhexue\Desktop\4.png)

32bitCPU 可寻址4G 线性空间，每个进程都有各自独立的4G 逻辑地址，其中0~3G 是用户态
空间，3~4G 是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其
划分如下：
各个段说明如下：
3G 用户空间和1G 内核空间
静态区域：
text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本
区存储程序的机器代码。
data segment(数据段)：存储程序中已初始化的全局变量和静态变量
bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0
的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main 之前时会统一清
零。即未初始化的全局变量编译器会初始化为0

动态区域：
heap（堆）： 当进程未调用malloc 时是没有堆段的，只有调用malloc 时采用分配一个堆，
并且在程序运行过程中可以动态增加堆大小(移动break 指针)，从低地址向高地址增长。分配小
内存时使用该区域。堆的起始地址由mm_struct 结构体中的start_brk 标识，结束地址由brk
标识。
memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc 时调
用mmap 函数）
stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低
地址增长。在创建进程时会有一个最大栈大小，Linux 可以通过ulimit 命令指定。



参考回答：
内存泄漏通常是由于调用了malloc/new 等内存申请的操作，但是缺少了对应的free/delete。
为了判断内存是否泄露，我们一方面可以使用linux 环境下的内存泄漏检查工具Valgrind,另一
方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，
以此来判断内存是否泄露。



内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。
内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对
该段内存的控制，因而造成了内存的浪费。
内存泄漏的分类：
1. 堆内存泄漏（Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc
    new 等从堆中分配的一块内存，再是完成后必须通过调用对应的free 或者delete 删掉。如果
    程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap
    Leak.
2. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如
    Bitmap,handle ,SOCKET 等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统
    效能降低，系统运行不稳定。
3. 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函
    数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内
    存泄露。

### **malloc的原理**，**另外**brk系统调用**和m**map**系统调用的作用分别是什么

Malloc 函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc 其采用内存
池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单
位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc 采用隐式链表结构将堆区
分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc 采用显示链表结构来管理
所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分
配的地址。
当进行内存分配时，Malloc 会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分
配；当进行内存合并时，malloc 采用边界标记法，根据每个块的前后块是否已经分配来决定是
否进行块合并。
Malloc 在申请内存时，一般会通过brk 或者mmap 系统调用进行申请。其中当申请内存小于
128K 时，会使用系统函数brk 在堆区中分配；而当申请内存大于128K 时，会使用系统函数mmap
在映射区分配。

### 什么时候会发生段错误 

段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：
使用野指针
试图修改字符串常量的内容

### reactor模型

reactor 模型要求主线程只负责监听文件描述上是否有事件发生，有的话就立即将该事件通
知工作线程，除此之外，主线程不做任何其他实质性的工作，读写数据、接受新的连接以及处理
客户请求均在工作线程中完成。

![5](C:\Users\yuhexue\Desktop\5.png)

1）Handle：即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开
的文件、一个连接(Socket)、Timer 等。由于Reactor 模式一般使用在网络编程中，因而这里一
般指Socket Handle，即一个网络连接。
2）Synchronous Event Demultiplexer（同步事件复用器）：阻塞等待一系列的Handle 中
的事件到来，如果阻塞等待返回，即表示在返回的Handle 中可以不阻塞的执行返回的事件类型。
这个模块一般使用操作系统的select 来实现。
3）Initiation Dispatcher：用于管理Event Handler，即EventHandler 的容器，用以注
册、移除EventHandler 等；另外，它还作为Reactor 模式的入口调用Synchronous Event
Demultiplexer 的select 方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle
将其分发给对应的Event Handler 处理，即回调EventHandler 中的handle_event()方法。
4）Event Handler：定义事件处理方法：handle_event()，以供InitiationDispatcher 回
调使用。
5）Concrete Event Handler：事件EventHandler 接口，实现特定事件处理逻辑。

### select，poll，epoll的区别**，**原理，性能，限制

select
select：是最初解决IO 阻塞问题的方法。用结构体fd_set 来告诉内核监听多个文件描述符，
该结构体被称为描述符集。由数组来维持哪些描述符被置位了。对结构体的操作封装在三个宏定
义中。通过轮寻来查找是否有描述符要被处理。
存在的问题：
1. 内置数组的形式使得select 的最大文件数受限与FD_SIZE；

2. 每次调用select 前都要重新初始化描述符集，将fd 从用户态拷贝到内核态，每次调用
    select 后，都需要将fd 从内核态拷贝到用户态；

3. 轮寻排查当文件描述符个数很多时，效率很低；
    3、poll
    poll：通过一个可变长度的数组解决了select 文件描述符受限的问题。数组中元素是结构
    体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只
    需要拷贝一次到内核态。poll 解决了select 重复初始化的问题。轮寻排查的问题未解决。
    4、epoll
    epoll：轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll 采用
    只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。

  

  epoll 对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT
  模式是默认模式

  1. LT 模式

    LT(level triggered)是缺省的工作方式，并且同时支持block 和no-block socket.在这种
    做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd 进行IO 操作。如
    果你不作任何操作，内核还是会继续通知你的。

2. ET 模式
    ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符
    从未就绪变为就绪时，内核通过epoll 告诉你。然后它会假设你知道文件描述符已经就绪，并且
    不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为
    就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一
    个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd 作IO 操作(从而导致它再次变成未
    就绪)，内核不会发送更多的通知(only once)
    ET 模式在很大程度上减少了epoll 事件被重复触发的次数，因此效率要比LT 模式高。epoll
    工作在ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作
    把处理多个文件描述符的任务饿死。
    3、LT 模式与ET 模式的区别如下：
    LT 模式：当epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不
    立即处理该事件。下次调用epoll_wait 时，会再次响应应用程序并通知此事件。
    ET 模式：当epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立
    即处理该事件。如果不处理，下次调用epoll_wait 时，不会再次响应应用程序并通知此事件。





### **C++11有哪些新特性**

C++11 最常用的新特性如下：
auto 关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类
型的推导
nullptr 关键字：nullptr 是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；
而NULL 一般被宏定义为0，在遇到重载时可能会出现问题。
智能指针：C++11 新增了std::shared_ptr、std::weak_ptr 等类型的智能指针，用于解决
内存管理的问题。
初始化列表：使用初始化列表来对类进行初始化
右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象
拷贝，节省运算存储资源，提高效率
atomic 原子操作用于多线程资源互斥操作
新增STL 容器array 以及tuple



 32位编译器：

​      char ：1个字节
​       **char\***（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）
​       short int : 2个字节
​       int：  4个字节
​       unsigned int : 4个字节
​       float:  4个字节
​       double:   8个字节
​       **long**:   4个字节
​       long long:  8个字节
​       **unsigned long**:  4个字节

  64位编译器：

​      char ：1个字节
​       **char\***(即指针变量): 8个字节
​       short int : 2个字节
​       int：  4个字节
​       unsigned int : 4个字节
​       float:  4个字节
​       double:   8个字节
​       long:   8个字节
​       long long:  8个字节
​       unsigned long:  8个字节

 

/*考察结构体对齐和填充：

结构体每个成员相对于结构体的**首地址的**偏移量都是成员大小的整数倍，如果不是，编译器会自动在成员间填充。*/

struct A {

int a;                            //4 bytes

char b;                        //1 bytes

//char pad[3]               //3 bytes

int c;                           //4 bytes

char d;                       //1 bytes

//char pad[3]              //3 bytes

}                            // total = 16 bytes

 

/* P中有结构体A的成员，但是计算时按照A中数据类型确定的*/

struct P {
 struct A w[2];    // 2 * 16 bytes

short b;            //2 bytes

//char pad[2]    //2 bytes

struct A* p;      //4 bytes
 }  // total = 40 bytes

 

32位系统中指针变量4字节，另外，当所有成员大小计算完毕后，编译器判断当前结构体大小是否是结构体中最宽的成员变量大小的整数倍 如果不是会在最后一个成员后做字节填充，可以解释最后补充的字节。

总结就是，成员间填充，结构体填充。

 

```
define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。const常量会在内存中分配(可以是堆中也可以是栈中)
const定义的常量在程序运行过程中只有一份拷贝，但#define定义的常量在预编译阶段就被替换，程序运行时不存在变量拷贝。
 
栈向下生长，堆向上生长（高到低，低到高，假想栈区在高，堆区在低）
```